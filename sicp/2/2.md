# 2.2 数据抽象

::: details INFO
译者：[Mancuoj](https://github.com/mancuoj)

来源：[2.2 Data Abstraction](https://www.composingprograms.com/pages/22-data-abstraction.html)

对应：无
:::

在程序中表示现实世界的各种事物时，绝大多数都具备复合结构。比如地理位置由经纬度组成。我们希望语言能把经度和纬度绑定成一对复合数据，既能当作单个概念操作，也能按两个部分分别处理。

复合数据让程序更模块化。如果能把位置当作整体值来操作，就能把计算位置的逻辑与位置的表示方式隔离开来。这种把“数据表示”与“数据处理”分离的设计叫做**数据抽象**，能显著提升程序的可设计性、可维护性与可修改性。

数据抽象与函数抽象同理。定义函数抽象时可以隐藏实现细节，任何具备相同行为的实现都能替换；也就是说，使用函数与函数的内部实现被解耦。类似地，数据抽象把复合数据的使用方式与其构造细节隔离。

核心思想是让程序操作抽象数据，对具体表示做最少假设，同时把数据的具体表示定义在独立部分。程序中“操作抽象数据”与“定义具体表示”两部分由一组函数衔接，这些函数根据具体表示实现抽象数据。为展示这一点，我们来设计一组操作有理数的函数。

## 2.2.1 示例：有理数

有理数是整数的比值，是实数的重要子集。`1/3` 或 `17/29` 一般写成：

```py
<分子>/<分母>
```

其中 `<分子>` 与 `<分母>` 都是整数占位符，这两个部分能精确表示一个有理数的值。直接做整数除法会产生 `float` 近似，失去整数的精度。

```py
>>> 1/3
0.3333333333333333
>>> 1/3 == 0.333333333333333300000  # 整数除法得到近似值
True
```

我们可以把分子和分母组合起来，得到有理数的精确表示。

利用函数抽象，我们可以在未实现细节前先搭好程序骨架。先假设已有从分子分母构造有理数的方法，也能分别取出它们。设想有这三个函数：

- `rational(n, d)` 返回分子为 `n`、分母为 `d` 的有理数
- `numer(x)` 返回有理数 `x` 的分子
- `denom(x)` 返回有理数 `x` 的分母

这里用到一个强大的策略：**一厢情愿（wishful thinking）**。即便还不知道有理数的表示或 `numer`、`denom`、`rational` 的实现，只要假设它们存在，就能先写出加法、乘法、打印以及相等性判断：

```py
>>> def add_rationals(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return rational(nx * dy + ny * dx, dx * dy)

>>> def mul_rationals(x, y):
        return rational(numer(x) * numer(y), denom(x) * denom(y))

>>> def print_rational(x):
        print(numer(x), '/', denom(x))

>>> def rationals_are_equal(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

现在有了基于 `numer`、`denom`、`rational` 的运算，但这些函数还没实现。我们需要一种方式把分子和分母粘合成复合值。

## 2.2.2 对

为了实现具体的数据抽象，Python 提供了复合结构 `list`，可通过逗号分隔的方括号构造，称为列表字面量。

```py
>>> [10, 20]
[10, 20]
```

访问列表元素有两种方式。其一是多重赋值，把列表解构成单个元素并分别绑定名称。

```py
>>> pair = [10, 20]
>>> pair
[10, 20]
>>> x, y = pair
>>> x
10
>>> y
20
```

第二种是元素选择运算符，也用方括号。跟在表达式后的方括号不会生成列表，而是从前面表达式的值里选出某个元素。

```py
>>> pair[0]
10
>>> pair[1]
20
```

Python（以及多数语言）的序列从 0 开始索引：0 是第一个元素，1 是第二个，以此类推。直觉上，索引表示元素距开头的偏移。

等价的函数是 `getitem`，同样用 0 索引选择元素。

```py
>>> from operator import getitem
>>> getitem(pair, 0)
10
>>> getitem(pair, 1)
20
```

双元素列表不是唯一的“对”表示。只要能把两个值捆成一个值，都可视作一对。列表是常用方式，也能容纳多于两个元素，本章稍后会继续介绍。

表示有理数：现在可以把有理数表示成两个整数的对：分子与分母。

```py
>>> def rational(n, d):
        return [n, d]

>>> def numer(x):
        return x[0]

>>> def denom(x):
        return x[1]
```

连同之前定义的算术运算，我们可以使用我们定义的函数来操作有理数。

```py
>>> half = rational(1, 2)
>>> print_rational(half)
1 / 2
>>> third = rational(1, 3)
>>> print_rational(mul_rationals(half, third))
1 / 6
>>> print_rational(add_rationals(third, third))
6 / 9
```

如上面的示例所示，我们的有理数实现不会将有理数简化为最小项。可以通过更改 `rational` 的实现来弥补这个缺陷。如果我们有一个计算两个整数的最大公分母的函数，我们可以用它在构造对之前将分子和分母减少到最低项。与许多有用的工具一样，这样的功能已经存在于 Python 库中。

```py
>>> from fractions import gcd
>>> def rational(n, d):
        g = gcd(n, d)
        return (n//g, d//g) # 译者注：此处使用 [n//g, d//g] 比较合适，因为目前仍然在使用列表来表示一个有理数
```

`//` 表示整数除法，它会将除法结果的小数部分向下舍入。因为我们知道 `g` 会将 `n` 和 `d` 均分，所以在这种情况下整数除法是精确的。这个修改后的 `rational` 实现会确保有理数以最小项表示。

```py
>>> print_rational(add_rationals(third, third))
2 / 3
```

这种改进是通过更改构造函数而不更改任何实现实际算术运算的函数来实现的。

## 2.2.3 抽象屏障

在继续更多复合数据和数据抽象的示例之前，让我们考虑一下有理数示例引发的一些问题。我们根据构造函数 `rational` 和选择器函数 `numer` 和 `denom` 来定义操作。一般来说，数据抽象的基本思想是确定一组基本操作，根据这些操作可以表达对某种值的所有操作，然后仅使用这些操作来操作数据。通过以这种方式限制操作的使用，在不改变程序行为的情况下改变抽象数据的表示会容易得多。

对于有理数，程序的不同部分使用不同的操作来处理有理数，如此表中所述。

| 该程序的一部分...          | 把有理数当作... | 仅使用...                                                         |
| -------------------------- | --------------- | ----------------------------------------------------------------- |
| 使用有理数进行计算         | 整个数据值      | `add_rational, mul_rational, rationals_are_equal, print_rational` |
| 创建有理数或操作有理数     | 分子和分母      | `rational, numer, denom`                                          |
| 为有理数实现选择器和构造器 | 二元列表        | 列表字面量和元素选择                                              |

在上面的每一层中，最后一列中的函数会强制实施抽象屏障（abstraction barrier）。这些功能会由更高层次调用，并使用较低层次的抽象实现。

当程序中有一部分本可以使用更高级别函数但却使用了低级函数时，就会违反抽象屏障。例如，计算有理数平方的函数最好用 `mul_rational` 实现，它不对有理数的实现做任何假设。

```py
>>> def square_rational(x):
        return mul_rational(x, x)
```

直接引用分子和分母会违反一个抽象屏障。

```py
>>> def square_rational_violating_once(x):
        return rational(numer(x) * numer(x), denom(x) * denom(x))
```

假设有理数会表示为双元素列表将违反两个抽象屏障。

```py
>>> def square_rational_violating_twice(x):
        return [x[0] * x[0], x[1] * x[1]]
```

抽象屏障使程序更易于维护和修改。依赖于特定表示的函数越少，想要更改该表示时所需的更改就越少。计算有理数平方的所有这些实现都具有正确的行为，但只有第一个函数对未来的更改是健壮的。即使我们修改了有理数的表示，`square_rational` 函数也不需要更新。相比之下，当选择器函数或构造函数签名发生变化后，`square_rational_violating_once` 就需要更改，而只要有理数的实现发生变化，`square_rational_violating_twice` 就需要更新。

## 2.2.4 数据的属性

抽象屏障塑造了我们思考数据的方式。有理数的表示不限于任何特定的实现（例如二元素列表）；它就是由 `rational` 返回的值，然后可以传递给 `numer` 和 `denom` 。此外，构造器和选择器之间必须保持适当的关系。也就是说，如果我们从整数 `n` 和 `d` 构造一个有理数 `x` ，那么 `numer(x)/denom(x)` 应该等于 `n/d` 。

通常，我们可以使用选择器和构造器的集合以及一些行为条件来表达抽象数据。只要满足行为条件（比如上面的除法属性），选择器和构造器就构成了一种数据的有效表示。抽象屏障下的实现细节可能会改变，但只要行为没有改变，那么数据抽象就仍然有效，并且使用该数据抽象编写的任何程序都将保持正确。

这种观点可以广泛应用，包括我们用来实现有理数的对。我们从来没有真正谈论什么是一对，只是语言提供了创建和操作二元列表的方法。我们需要实现一对的行为是它将两个值粘合在一起。作为一种行为条件，

- 如果一对 `p` 由值 `x` 和 `y` 构成，则 `select(p, 0)` 返回 `x`， `select(p, 1)` 返回 `y`

我们实际上并不一定需要 `list` 类型来创建对，作为替代，我们可以用两个函数 `pair` 和 `select` 来实现这个描述以及一个二元列表。

```py
>>> def pair(x, y):
        """Return a function that represents a pair."""
        def get(index):
            if index == 0:
                return x
            elif index == 1:
                return y
        return get

>>> def select(p, i):
        """Return the element at index i of pair p."""
        return p(i)
```

通过这个实现，我们可以创建和操作对。

```py
>>> p = pair(20, 14)
>>> select(p, 0)
20
>>> select(p, 1)
14
```

这种高阶函数的使用完全不符合我们对数据应该是什么的直觉概念。但尽管如此，这些函数足以在我们的程序中表示对，也足以表示复合数据。

这种表示对的函数表示的重点并不是 Python 实际上以这种方式工作（出于效率原因，列表更直接地实现），而是它可以以这种方式工作。函数表示虽然晦涩难懂，但却是表示对的一个完全合适的方法，因为它满足了表示对需要满足的唯一条件。数据抽象的实践使我们能够轻松地在表示之间切换。
