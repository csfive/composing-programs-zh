# 2.4 可变数据

:::info
译者：

来源：[2.4 Mutable Data](http://composingprograms.com/pages/24-mutable-data.html)

对应：Lab 05
:::



We have seen how abstraction is vital in helping us to cope with the complexity of large systems. Effective programming also requires organizational principles that can guide us in formulating the overall design of a program. In particular, we need strategies to help us structure large systems to be modular, meaning that they divide naturally into coherent parts that can be separately developed and maintained.
我们已经看到了抽象在帮助我们科普大型系统的复杂性方面是多么的重要。有效的程序设计还需要组织原则，这些原则可以指导我们制定程序的总体设计。特别是，我们需要一些策略来帮助我们将大型系统构建成模块化的，也就是说，它们自然地划分成可以单独开发和维护的连贯部分。

One powerful technique for creating modular programs is to incorporate data that may change state over time. In this way, a single data object can represent something that evolves independently of the rest of the program. The behavior of a changing object may be influenced by its history, just like an entity in the world. Adding state to data is a central ingredient of a paradigm called object-oriented programming.
创建模块化程序的一个强大技术是合并可能随时间改变状态的数据。通过这种方式，单个数据对象可以表示独立于程序其余部分而发展的内容。变化对象的行为可能会受到其历史的影响，就像世界上的实体一样。向数据添加状态是一种称为面向对象编程的范例的核心要素。

## 2.4.1  The Object Metaphor 2.4.1 宾语隐喻

In the beginning of this text, we distinguished between functions and data: functions performed operations and data were operated upon. When we included function values among our data, we acknowledged that data too can have behavior. Functions could be manipulated as data, but could also be called to perform computation.
在本文的开头，我们区分了函数和数据：函数执行操作并且数据被操作。当我们在数据中包含函数值时，我们承认数据也可以有行为。函数可以作为数据进行操作，但也可以被调用来执行计算。

*Objects* combine data values with behavior. Objects represent information, but also *behave* like the things that they represent. The logic of how an object interacts with other objects is bundled along with the information that encodes the object's value. When an object is printed, it knows how to spell itself out in text. If an object is composed of parts, it knows how to reveal those parts on demand. Objects are both information and processes, bundled together to represent the properties, interactions, and behaviors of complex things.
对象将数据值与行为组合在一起。对象表示信息，但行为也像它们所表示的事物。对象如何与其他对象交互的逻辑与编码对象值的信息捆绑在一起。当一个对象被打印出来时，它知道如何在文本中拼写自己。如果一个对象由多个部分组成，它知道如何根据需要显示这些部分。对象既是信息又是过程，捆绑在一起表示复杂事物的属性、交互和行为。

Object behavior is implemented in Python through specialized object syntax and associated terminology, which we can introduce by example. A date is a kind of object.
对象行为在Python中是通过专门的对象语法和相关术语实现的，我们可以通过示例来介绍。日期是一种对象。

```
>>> from datetime import date
```

The name `date` is bound to a *class*. As we have seen, a class represents a kind of value. Individual dates are called *instances* of that class. Instances can be *constructed* by calling the class on arguments that characterize the instance.
名称 `date` 已绑定到类。正如我们所看到的，一个类代表一种值。单个日期称为该类的实例。实例可以通过在表征实例的参数上调用类来构造。

```
>>> tues = date(2014, 5, 13)
```

While `tues` was constructed from primitive numbers, it behaves like a date. For instance, subtracting it from another date will give a time difference, which we can print.
虽然 `tues` 是由原始数字构造的，但它的行为类似于日期。例如，从另一个日期减去它将给予一个时间差，我们可以打印出来。

```
>>> print(date(2014, 5, 19) - tues)
6 days, 0:00:00
```

Objects have *attributes*, which are named values that are part of the object. In Python, like many other programming languages, we use dot notation to designated an attribute of an object.
对象具有属性，属性是作为对象一部分的命名值。在Python中，像许多其他编程语言一样，我们使用点符号来指定对象的属性。

> `<expression> . <name> <expression>。<name>`

Above, the `<expression>` evaluates to an object, and `<name>` is the name of an attribute for that object.
在上面， `<expression>` 的计算结果是一个对象，而 `<name>` 是该对象的属性名。

Unlike the names that we have considered so far, these attribute names are not available in the general environment. Instead, attribute names are particular to the object instance preceding the dot.
与我们到目前为止所考虑的名称不同，这些属性名称在一般环境中不可用。相反，属性名称特定于点之前的对象实例。

```
>>> tues.year
2014
```

Objects also have *methods*, which are function-valued attributes. Metaphorically, we say that the object "knows" how to carry out those methods. By implementation, methods are functions that compute their results from both their arguments and their object. For example, The `strftime` method (a classic function name meant to evoke "string format of time") of `tues` takes a single argument that specifies how to display a date (e.g., `%A` means that the day of the week should be spelled out in full).
对象也有方法，这些方法是函数值属性。打个比方，我们说对象“知道”如何执行这些方法。通过实现，方法是从其参数和对象计算结果的函数。例如， `tues` 的 `strftime` 方法（一个经典的函数名，意在唤起“时间的字符串格式”）采用指定如何显示日期的单个参数（例如， `%A` 表示一周中的哪一天应完整拼写）。

```
>>> tues.strftime('%A, %B %d')
'Tuesday, May 13'
```

Computing the return value of `strftime` requires two inputs: the string that describes the format of the output and the date information bundled into `tues`. Date-specific logic is applied within this method to yield this result. We never stated that the 13th of May, 2014, was a Tuesday, but knowing the corresponding weekday is part of what it means to be a date. By bundling behavior and information together, this Python object offers us a convincing, self-contained abstraction of a date.
计算 `strftime` 的返回值需要两个输入：描述输出格式的字符串和捆绑到 `tues` 中的日期信息。在此方法中应用了特定于日期的逻辑以生成此结果。我们从未说过2014年5月13日是星期二，但知道相应的工作日是约会的一部分。通过将行为和信息捆绑在一起，这个Python对象为我们提供了一个令人信服的、自包含的日期抽象。

Dates are objects, but numbers, strings, lists, and ranges are all objects as well. They represent values, but also behave in a manner that befits the values they represent. They also have attributes and methods. For instance, strings have an array of methods that facilitate text processing.
日期是对象，但数字、字符串、列表和范围也都是对象。它们代表价值观，但也以适合它们所代表的价值观的方式表现。它们也有属性和方法。例如，字符串有一个便于文本处理的方法数组。

```
>>> '1234'.isnumeric()
True
>>> 'rOBERT dE nIRO'.swapcase()
'Robert De Niro'
>>> 'eyes'.upper().endswith('YES')
True
```

In fact, all values in Python are objects. That is, all values have behavior and attributes. They act like the values they represent.
事实上，Python中的所有值都是对象。也就是说，所有值都有行为和属性。他们的行为就像他们所代表的价值观。

## 2.4.2  Sequence Objects 2.4.2 序列对象

Instances of primitive built-in values such as numbers are *immutable*. The values themselves cannot change over the course of program execution. Lists on the other hand are *mutable*.
基元内置值（如数字）的实例是不可变的。这些值本身不能在程序执行过程中更改。另一方面，列表是可变的。

Mutable objects are used to represent values that change over time. A person is the same person from one day to the next, despite having aged, received a haircut, or otherwise changed in some way. Similarly, an object may have changing properties due to *mutating* operations. For example, it is possible to change the contents of a list. Most changes are performed by invoking methods on list objects.
可变对象用于表示随时间变化的值。一个人从一天到下一天都是同一个人，尽管他变老了，剪了头发，或者在某些方面发生了变化。类似地，对象可能由于变异操作而具有变化的属性。例如，可以更改列表的内容。大多数更改都是通过调用列表对象上的方法来执行的。

We can introduce many list modification operations through an example that illustrates the history of playing cards (drastically simplified). Comments in the examples describe the effect of each method invocation.
我们可以通过一个演示扑克牌历史的示例来介绍许多列表修改操作（大大简化了）。示例中的注释描述了每个方法调用的效果。

Playing cards were invented in China, perhaps around the 9th century. An early deck had three suits, which corresponded to denominations of money.
扑克牌是在中国发明的，大概是在9世纪左右。早期的一副牌有三种花色，与货币的面额相对应。

```
>>> chinese = ['coin', 'string', 'myriad']  # A list literal
>>> suits = chinese                         # Two names refer to the same list
```

As cards migrated to Europe (perhaps through Egypt), only the suit of coins remained in Spanish decks (*oro*).
当纸牌传到欧洲时（可能是通过埃及），西班牙的纸牌（oro）中只剩下一套硬币。

```
>>> suits.pop()             # Remove and return the final element
'myriad'
>>> suits.remove('string')  # Remove the first element that equals the argument
```

Three more suits were added (they evolved in name and design over time),
又增加了三套西装（它们的名字和设计随着时间的推移而演变），

```
>>> suits.append('cup')              # Add an element to the end
>>> suits.extend(['sword', 'club'])  # Add all elements of a sequence to the end
```

and Italians called swords *spades*.
意大利人把剑叫做黑桃。

```
>>> suits[2] = 'spade'  # Replace an element
```

giving the suits of a traditional Italian deck of cards.
给出传统意大利扑克牌的花色。

```
>>> suits
['coin', 'cup', 'spade', 'club']
```

The French variant used today in the U.S. changes the first two suits:
今天在美国使用的法语变体改变了前两种花色：

```
>>> suits[0:2] = ['heart', 'diamond']  # Replace a slice
>>> suits
['heart', 'diamond', 'spade', 'club']
```

Methods also exist for inserting, sorting, and reversing lists. All of these mutation operations change the value of the list; they do not create new list objects.
还存在用于插入、排序和反转列表的方法。所有这些变异操作都改变列表的值;它们不创建新的列表对象。

**Sharing and Identity.** Because we have been changing a single list rather than creating new lists, the object bound to the name `chinese` has also changed, because it is the same list object that was bound to `suits`!
共享和身份。因为我们一直在更改单个列表而不是创建新列表，所以绑定到名称 `chinese` 的对象也更改了，因为它与绑定到 `suits` 的列表对象是同一个列表对象！

```
>>> chinese  # This name co-refers with "suits" to the same changing list
['heart', 'diamond', 'spade', 'club']
```

This behavior is new. Previously, if a name did not appear in a statement, then its value would not be affected by that statement. With mutable data, methods called on one name can affect another name at the same time.
这种行为是新的。以前，如果名称未出现在语句中，则其值不会受该语句的影响。对于可变数据，对一个名称调用的方法可以同时影响另一个名称。

The environment diagram for this example shows how the value bound to `chinese` is changed by statements involving only `suits`. Step through each line of the following example to observe these changes.
此示例的环境关系图显示绑定到 `chinese` 的值如何由仅涉及 `suits` 的语句更改。单步执行以下示例的每一行以观察这些更改。



Lists can be copied using the `list` constructor function. Changes to one list do not affect another, unless they share structure.
可以使用 `list` 构造函数复制列表。对一个列表的更改不会影响另一个列表，除非它们共享结构。

```
>>> nest = list(suits)  # Bind "nest" to a second list with the same elements
>>> nest[0] = suits     # Create a nested list
```

According to this environment, changing the list referenced by `suits` will affect the nested list that is the first element of `nest`, but not the other elements.
根据此环境，更改 `suits` 引用的列表将影响作为 `nest` 的第一个元素的嵌套列表，但不影响其他元素。

```
>>> suits.insert(2, 'Joker')  # Insert an element at index 2, shifting the rest
>>> nest
[['heart', 'diamond', 'Joker', 'spade', 'club'], 'diamond', 'spade', 'club']
```

And likewise, undoing this change in the first element of `nest` will change `suit` as well.
同样，撤消 `nest` 的第一个元素中的更改也会更改 `suit` 。

```
>>> nest[0].pop(2)
'Joker'
>>> suits
['heart', 'diamond', 'spade', 'club']
```

Stepping through this example line by line will show the representation of a nested list.
逐行执行此示例将显示嵌套列表的表示。



Because two lists may have the same contents but in fact be different lists, we require a means to test whether two objects are the same. Python includes two comparison operators, called `is` and `is not`, that test whether two expressions in fact evaluate to the identical object. Two objects are identical if they are equal in their current value, and any change to one will always be reflected in the other. Identity is a stronger condition than equality.
因为两个列表可能具有相同的内容，但实际上是不同的列表，所以我们需要一种方法来测试两个对象是否相同。Python包含了两个比较运算符，分别叫做 `is` 和 `is not` ，它们测试两个表达式是否实际上计算出相同的对象。如果两个对象的当前值相等，则它们是相同的，并且对一个对象的任何更改将始终反映在另一个对象中。同一性是比平等更强有力的条件。

```
>>> suits is nest[0]
True
>>> suits is ['heart', 'diamond', 'spade', 'club']
False
>>> suits == ['heart', 'diamond', 'spade', 'club']
True
```

The final two comparisons illustrate the difference between `is` and `==`. The former checks for identity, while the latter checks for the equality of contents.
最后两项比较说明了 `is` 和 `==` 之间的差异。前者检查同一性，而后者检查内容的相等性。

**List comprehensions.** A list comprehension always creates a new list. For example, the `unicodedata` module tracks the official names of every character in the Unicode alphabet. We can look up the characters corresponding to names, including those for card suits.
列出理解。列表解析总是创建一个新列表。例如， `unicodedata` 模块跟踪Unicode字母表中每个字符的正式名称。我们可以查找与名字相对应的字符，包括用于牌组的字符。

```
>>> from unicodedata import lookup
>>> [lookup('WHITE ' + s.upper() + ' SUIT') for s in suits]
['♡', '♢', '♤', '♧']
```

This resulting list does not share any of its contents with `suits`, and evaluating the list comprehension does not modify the `suits` list.
该结果列表不与 `suits` 共享其任何内容，并且评估列表理解不修改 `suits` 列表。

You can read more about the Unicode standard for representing text in the [Unicode section](http://getpython3.com/diveintopython3/strings.html#one-ring-to-rule-them-all) of Dive into Python 3.
您可以在深入了解Python 3的Unicode一节中阅读更多关于表示文本的Unicode标准的内容。

**Tuples.** A tuple, an instance of the built-in `tuple` type, is an immutable sequence. Tuples are created using a tuple literal that separates element expressions by commas. Parentheses are optional but used commonly in practice. Any objects can be placed within tuples.
元组。元组是内置 `tuple` 类型的实例，是不可变的序列。元组是使用以逗号分隔元素表达式的元组文本创建的。圆括号是可选的，但在实践中经常使用。任何对象都可以放在元组中。

```
>>> 1, 2 + 3
(1, 5)
>>> ("the", 1, ("and", "only"))
('the', 1, ('and', 'only'))
>>> type( (10, 20) )
<class 'tuple'>
```

Empty and one-element tuples have special literal syntax.
空元组和单元素元组具有特殊的文本语法。

```
>>> ()    # 0 elements
()
>>> (10,) # 1 element
(10,)
```

Like lists, tuples have a finite length and support element selection. They also have a few methods that are also available for lists, such as `count` and `index`.
和列表一样，元组的长度有限，并且支持元素选择。它们还有一些方法也可用于列表，如 `count` 和 `index` 。

```
>>> code = ("up", "up", "down", "down") + ("left", "right") * 2
>>> len(code)
8
>>> code[3]
'down'
>>> code.count("down")
2
>>> code.index("left")
4
```

However, the methods for manipulating the contents of a list are not available for tuples because tuples are immutable.
但是，用于操作列表内容的方法不适用于元组，因为元组是不可变的。

While it is not possible to change which elements are in a tuple, it is possible to change the value of a mutable element contained within a tuple.
虽然不可能更改元组中的元素，但可以更改元组中包含的可变元素的值。



Tuples are used implicitly in multiple assignment. An assignment of two values to two names creates a two-element tuple and then unpacks it.
元组隐式用于多重赋值。将两个值赋给两个名称会创建一个两元素元组，然后将其解包。

## 2.4.3  Dictionaries 2.4.3 字典

Dictionaries are Python's built-in data type for storing and manipulating correspondence relationships. A dictionary contains key-value pairs, where both the keys and values are objects. The purpose of a dictionary is to provide an abstraction for storing and retrieving values that are indexed not by consecutive integers, but by descriptive keys.
字典是Python内置的数据类型，用于存储和操作对应关系。字典包含键-值对，其中键和值都是对象。字典的目的是为存储和检索不是由连续整数而是由描述性键索引的值提供抽象。

Strings commonly serve as keys, because strings are our conventional representation for names of things. This dictionary literal gives the values of various Roman numerals.
字符串通常用作键，因为字符串是事物名称的常规表示。这个字典文字给出了各种罗马数字的值。

```
>>> numerals = {'I': 1.0, 'V': 5, 'X': 10}
```

Looking up values by their keys uses the element selection operator that we previously applied to sequences.
通过键查找值使用了我们之前应用于序列的元素选择操作符。

```
>>> numerals['X']
10
```

A dictionary can have at most one value for each key. Adding new key-value pairs and changing the existing value for a key can both be achieved with assignment statements.
字典中的每个键最多只能有一个值。添加新的键-值对和更改键的现有值都可以使用赋值语句实现。

```
>>> numerals['I'] = 1
>>> numerals['L'] = 50
>>> numerals
{'I': 1, 'X': 10, 'L': 50, 'V': 5}
```

Notice that `'L'` was not added to the end of the output above. Dictionaries are unordered collections of key-value pairs. When we print a dictionary, the keys and values are rendered in some order, but as users of the language we cannot predict what that order will be. The order may change when running a program multiple times.
请注意， `'L'` 没有添加到上面输出的末尾。字典是键值对的无序集合。当我们打印字典时，键和值是按照某种顺序呈现的，但是作为语言的用户，我们无法预测这个顺序会是什么。多次运行程序时，顺序可能会改变。

Dictionaries can appear in environment diagrams as well.
字典也可以出现在环境图中。



The dictionary type also supports various methods of iterating over the contents of the dictionary as a whole. The methods `keys`, `values`, and `items` all return iterable values.
dictionary类型还支持对整个字典的内容进行迭代的各种方法。方法 `keys` 、 `values` 和 `items` 都返回可迭代值。

```
>>> sum(numerals.values())
66
```

A list of key-value pairs can be converted into a dictionary by calling the `dict` constructor function.
键值对列表可以通过调用 `dict` 构造函数转换为字典。

```
>>> dict([(3, 9), (4, 16), (5, 25)])
{3: 9, 4: 16, 5: 25}
```

Dictionaries do have some restrictions:
字典确实有一些限制：

- A key of a dictionary cannot be or contain a mutable value.
    字典的键不能是或包含可变值。
- There can be at most one value for a given key.
    一个给定的键最多只能有一个值。

This first restriction is tied to the underlying implementation of dictionaries in Python. The details of this implementation are not a topic of this text. Intuitively, consider that the key tells Python where to find that key-value pair in memory; if the key changes, the location of the pair may be lost. Tuples are commonly used for keys in dictionaries because lists cannot be used.
第一个限制与Python中字典的底层实现有关。这个实现的细节不是本文的主题。直观地说，考虑键告诉Python在内存中何处找到键值对;如果密钥改变，则该对的位置可能丢失。元组通常用作字典中的键，因为不能使用列表。

The second restriction is a consequence of the dictionary abstraction, which is designed to store and retrieve values for keys. We can only retrieve *the* value for a key if at most one such value exists in the dictionary.
第二个限制是字典抽象的结果，字典抽象是为了存储和检索键的值而设计的。只有当字典中最多存在一个这样的值时，我们才能检索键的值。

A useful method implemented by dictionaries is `get`, which returns either the value for a key, if the key is present, or a default value. The arguments to `get` are the key and the default value.
字典实现的一个有用方法是 `get` ，它返回键的值（如果存在键）或默认值。 `get` 的参数是键和默认值。

```
>>> numerals.get('A', 0)
0
>>> numerals.get('V', 0)
5
```

Dictionaries also have a comprehension syntax analogous to those of lists. A key expression and a value expression are separated by a colon. Evaluating a dictionary comprehension creates a new dictionary object.
字典也有类似于列表的理解语法。键表达式和值表达式由冒号分隔。计算字典解析将创建一个新的字典对象。

```
>>> {x: x*x for x in range(3,6)}
{3: 9, 4: 16, 5: 25}
```

## 2.4.4  Local State 2.4.4 地方政府

Lists and dictionaries have *local state*: they are changing values that have some particular contents at any point in the execution of a program. The word "state" implies an evolving process in which that state may change.
列表和字典具有本地状态：它们是在程序执行中的任何点改变具有某些特定内容的值。“状态”一词意味着一个不断演变的过程，在这个过程中，状态可能发生变化。

Functions can also have local state. For instance, let us define a function that models the process of withdrawing money from a bank account. We will create a function called `withdraw`, which takes as its argument an amount to be withdrawn. If there is enough money in the account to accommodate the withdrawal, then `withdraw` will return the balance remaining after the withdrawal. Otherwise, `withdraw` will return the message `'Insufficient funds'`. For example, if we begin with $100 in the account, we would like to obtain the following sequence of return values by calling withdraw:
函数也可以具有局部状态。例如，让我们定义一个函数来模拟从银行帐户中取钱的过程。我们将创建一个名为 `withdraw` 的函数，该函数的参数为要提取的金额。如果账户中有足够的钱来支付取款，那么 `withdraw` 将返还取款后的余额。否则， `withdraw` 将返回消息 `'Insufficient funds'` 。例如，如果我们的帐户以$100开始，我们希望通过调用withdraw获得以下返回值序列：

```
>>> withdraw(25)
75
>>> withdraw(25)
50
>>> withdraw(60)
'Insufficient funds'
>>> withdraw(15)
35
```

Above, the expression `withdraw(25)`, evaluated twice, yields different values. Thus, this user-defined function is non-pure. Calling the function not only returns a value, but also has the side effect of changing the function in some way, so that the next call with the same argument will return a different result. This side effect is a result of `withdraw` making a change to a name-value binding outside of the current frame.
在上面，表达式 `withdraw(25)` 计算了两次，产生了不同的值。因此，这个用户定义函数是非纯函数。调用函数不仅返回一个值，而且还会产生以某种方式更改函数的副作用，这样下一次使用相同参数的调用就会返回不同的结果。此副作用是 `withdraw` 在当前框架之外更改名称-值绑定的结果。

For `withdraw` to make sense, it must be created with an initial account balance. The function `make_withdraw` is a higher-order function that takes a starting balance as an argument. The function `withdraw` is its return value.
要使 `withdraw` 有意义，必须使用初始帐户余额创建它。函数 `make_withdraw` 是将开始余额作为参数的高阶函数。函数 `withdraw` 是它的返回值。

```
>>> withdraw = make_withdraw(100)
```

An implementation of `make_withdraw` requires a new kind of statement: a `nonlocal` statement. When we call `make_withdraw`, we bind the name `balance` to the initial amount. We then define and return a local function, `withdraw`, which updates and returns the value of `balance` when called.
`make_withdraw` 的实现需要一种新的语句：第一句话。当我们调用 `make_withdraw` 时，我们将名称 `balance` 绑定到初始金额。然后我们定义并返回一个局部函数 `withdraw` ，它在被调用时更新并返回 `balance` 的值。

```
>>> def make_withdraw(balance):
        """Return a withdraw function that draws down balance with each call."""
        def withdraw(amount):
            nonlocal balance                 # Declare the name "balance" nonlocal
            if amount > balance:
                return 'Insufficient funds'
            balance = balance - amount       # Re-bind the existing balance name
            return balance
        return withdraw
```

The `nonlocal` statement declares that whenever we change the binding of the name `balance`, the binding is changed in the first frame in which `balance` is already bound. Recall that without the `nonlocal` statement, an assignment statement would always bind a name in the first frame of the current environment. The `nonlocal` statement indicates that the name appears somewhere in the environment other than the first (local) frame or the last (global) frame.
`nonlocal` 语句声明每当我们改变名称 `balance` 的绑定时，在已经绑定了 `balance` 的第一帧中改变绑定。回想一下，如果没有 `nonlocal` 语句，赋值语句将始终绑定当前环境的第一帧中的名称。 `nonlocal` 语句表示名称出现在环境中的某个地方，而不是第一个（局部）帧或最后一个（全局）帧。

The following environment diagrams illustrate the effects of multiple calls to a function created by `make_withdraw`.
下面的环境关系图说明了多次调用 `make_withdraw` 创建的函数的效果。



The first def statement has the usual effect: it creates a new user-defined function and binds the name `make_withdraw` to that function in the global frame. The subsequent call to `make_withdraw` creates and returns a locally defined function `withdraw`. The name `balance` is bound in the parent frame of this function. Crucially, there will only be this single binding for the name `balance` throughout the rest of this example.
第一个def语句具有通常的效果：它创建一个新的用户定义函数，并将名称 `make_withdraw` 绑定到全局帧中的该函数。对 `make_withdraw` 的后续调用创建并返回本地定义的函数 `withdraw` 。名称 `balance` 绑定在此函数的父框架中。至关重要的是，在本示例的其余部分中，名称 `balance` 只有一个绑定。

Next, we evaluate an expression that calls this function, bound to the name `wd`, on an amount 5. The body of `withdraw` is executed in a new environment that extends the environment in which `withdraw` was defined. Tracing the effect of evaluating `withdraw` illustrates the effect of a `nonlocal` statement in Python: a name outside of the first local frame can be changed by an assignment statement.
接下来，我们对一个调用此函数的表达式求值，该表达式绑定到名称 `wd` ，值为5。 `withdraw` 的主体在扩展了定义 `withdraw` 的环境的新环境中执行。跟踪计算 `withdraw` 的效果说明了Python中 `nonlocal` 语句的效果：可以通过赋值语句来改变第一本地帧之外的名称。



The `nonlocal` statement changes all of the remaining assignment statements in the definition of `withdraw`. After executing `nonlocal balance`, any assignment statement with `balance` on the left-hand side of `=` will not bind `balance` in the first frame of the current environment. Instead, it will find the first frame in which `balance` was already defined and re-bind the name in that frame. If `balance` has not previously been bound to a value, then the `nonlocal` statement will give an error.
`nonlocal` 语句更改 `withdraw` 定义中所有剩余的赋值语句。在执行 `nonlocal balance` 之后，在当前环境的第一帧中，任何在 `=` 左侧具有 `balance` 的赋值语句都不会绑定 `balance` 。相反，它将找到第一个已经定义了 `balance` 的帧，并在该帧中重新绑定名称。如果 `balance` 之前没有绑定到某个值，则 `nonlocal` 语句将给予错误。

By virtue of changing the binding for `balance`, we have changed the `withdraw` function as well. The next time it is called, the name `balance` will evaluate to 15 instead of 20. Hence, when we call `withdraw` a second time, we see that its return value is 12 and not 17. The change to `balance` from the first call affects the result of the second call.
通过更改 `balance` 的绑定，我们也更改了 `withdraw` 函数。下次调用它时，名称 `balance` 的计算结果将为15而不是20。因此，当我们第二次调用 `withdraw` 时，我们看到它的返回值是12而不是17。从第一次调用更改为 `balance` 会影响第二次调用的结果。



The second call to `withdraw` does create a second local frame, as usual. However, both `withdraw` frames have the same parent. That is, they both extend the environment for `make_withdraw`, which contains the binding for `balance`. Hence, they share that particular name binding. Calling `withdraw` has the side effect of altering the environment that will be extended by future calls to `withdraw`. The `nonlocal` statement allows `withdraw` to change a name binding in the `make_withdraw` frame.
对 `withdraw` 的第二次调用照常创建第二个本地帧。但是，两个 `withdraw` 帧具有相同的父帧。也就是说，它们都扩展了 `make_withdraw` 的环境，其中包含 `balance` 的绑定。因此，它们共享那个特定的名称绑定。调用 `withdraw` 的副作用是改变环境，将来对 `withdraw` 的调用将扩展该环境。 `nonlocal` 语句允许 `withdraw` 更改 `make_withdraw` 框架中的名称绑定。

Ever since we first encountered nested `def` statements, we have observed that a locally defined function can look up names outside of its local frames. No `nonlocal` statement is required to *access* a non-local name. By contrast, only after a `nonlocal` statement can a function *change* the binding of names in these frames.
自从我们第一次遇到嵌套的 `def` 语句以来，我们已经观察到局部定义的函数可以查找其局部框架之外的名称。访问非本地名称不需要 `nonlocal` 语句。相比之下，只有在 `nonlocal` 语句之后，函数才能更改这些框架中名称的绑定。

By introducing `nonlocal` statements, we have created a dual role for assignment statements. Either they change local bindings, or they change nonlocal bindings. In fact, assignment statements already had a dual role: they either created new bindings or re-bound existing names. Assignment can also change the contents of lists and dictionaries. The many roles of Python assignment can obscure the effects of executing an assignment statement. It is up to you as a programmer to document your code clearly so that the effects of assignment can be understood by others.
通过引入 `nonlocal` 语句，我们为赋值语句创建了双重角色。它们要么更改本地绑定，要么更改非本地绑定。实际上，赋值语句已经有了双重角色：它们或者创建新绑定或者重新绑定现有名称。赋值还可以更改列表和字典的内容。Python赋值语句的许多角色会使执行赋值语句的效果变得模糊。作为程序员，您需要清楚地记录代码，以便其他人能够理解赋值的效果。

**Python Particulars.** This pattern of non-local assignment is a general feature of programming languages with higher-order functions and lexical scope. Most other languages do not require a `nonlocal` statement at all. Instead, non-local assignment is often the default behavior of assignment statements.
蟒蛇的细节。这种非本地赋值模式是具有高阶函数和词法作用域的编程语言的一般特征。大多数其他语言根本不需要 `nonlocal` 语句。相反，非本地赋值通常是赋值语句的默认行为。

Python also has an unusual restriction regarding the lookup of names: within the body of a function, all instances of a name must refer to the same frame. As a result, Python cannot look up the value of a name in a non-local frame, then bind that same name in the local frame, because the same name would be accessed in two different frames in the same function. This restriction allows Python to pre-compute which frame contains each name before executing the body of a function. When this restriction is violated, a confusing error message results. To demonstrate, the `make_withdraw` example is repeated below with the `nonlocal` statement removed.
Python还有一个关于名字查找的特殊限制：在函数体中，一个名字的所有实例必须引用同一帧。结果，Python无法在非本地框架中查找名称的值，然后在本地框架中绑定相同的名称，因为相同的名称会在同一函数的两个不同框架中被访问。这一限制允许Python在执行函数体之前预先计算每个名称包含在哪个帧中。违反此限制时，会产生令人困惑的错误消息。为了进行演示，下面重复 `make_withdraw` 示例，但删除了 `nonlocal` 语句。



This `UnboundLocalError` appears because `balance` is assigned locally in line 5, and so Python assumes that all references to `balance` must appear in the local frame as well. This error occurs *before* line 5 is ever executed, implying that Python has considered line 5 in some way before executing line 3. As we study interpreter design, we will see that pre-computing facts about a function body before executing it is quite common. In this case, Python's pre-processing restricted the frame in which `balance` could appear, and thus prevented the name from being found. Adding a `nonlocal` statement corrects this error. The `nonlocal` statement did not exist in Python 2.
这个 `UnboundLocalError` 出现是因为 `balance` 在第5行被本地赋值，所以Python假设所有对 `balance` 的引用也必须出现在本地框架中。这个错误发生在第5行执行之前，意味着Python在执行第3行之前已经以某种方式考虑了第5行。当我们研究解释器设计时，我们会看到在执行函数体之前预先计算关于函数体的事实是很常见的。在这种情况下，Python的预处理限制了 `balance` 可能出现的框架，因此阻止了名称被找到。添加 `nonlocal` 语句可以纠正这个错误。 `nonlocal` 语句在Python 2中不存在。

## 2.4.5  The Benefits of Non-Local Assignment 2.4.5 非本地外派的好处

Non-local assignment is an important step on our path to viewing a program as a collection of independent and autonomous *objects*, which interact with each other but each manage their own internal state.
非局部赋值是我们将程序视为独立和自治对象的集合的重要一步，这些对象彼此交互，但各自管理自己的内部状态。

In particular, non-local assignment has given us the ability to maintain some state that is local to a function, but evolves over successive calls to that function. The `balance` associated with a particular withdraw function is shared among all calls to that function. However, the binding for balance associated with an instance of withdraw is inaccessible to the rest of the program. Only `wd` is associated with the frame for `make_withdraw` in which it was defined. If `make_withdraw` is called again, then it will create a separate frame with a separate binding for `balance`.
特别是，非本地赋值给了我们维护某个函数本地状态的能力，但是会随着对该函数的连续调用而演化。与特定withdraw函数关联的 `balance` 在对该函数的所有调用中共享。但是，程序的其余部分无法访问与withdraw实例关联的balance绑定。只有 `wd` 与定义它的 `make_withdraw` 的帧相关联。如果再次调用 `make_withdraw` ，则它将为 `balance` 创建一个单独绑定的单独框架。

We can extend our example to illustrate this point. A second call to `make_withdraw` returns a second `withdraw` function that has a different parent. We bind this second function to the name `wd2` in the global frame.
我们可以扩展我们的例子来说明这一点。对 `make_withdraw` 的第二次调用返回具有不同父级的第二个 `withdraw` 函数。我们将第二个函数绑定到全局框架中的名称 `wd2` 。



Now, we see that there are in fact two bindings for the name `balance` in two different frames, and each `withdraw` function has a different parent. The name `wd` is bound to a function with a balance of 20, while `wd2` is bound to a different function with a balance of 7.
现在，我们可以看到，在两个不同的框架中，名称 `balance` 实际上有两个绑定，并且每个 `withdraw` 函数都有一个不同的父函数。名称 `wd` 绑定到一个余额为20的函数，而 `wd2` 绑定到另一个余额为7的函数。

Calling `wd2` changes the binding of its non-local `balance` name, but does not affect the function bound to the name `withdraw`. A future call to `wd` is unaffected by the changing balance of `wd2`; its balance is still 20.
调用 `wd2` 会更改其非本地 `balance` 名称的绑定，但不会影响绑定到名称 `withdraw` 的函数。对 `wd` 的未来调用不受 `wd2` 的变化余额的影响;它余额仍然是20。



In this way, each instance of `withdraw` maintains its own balance state, but that state is inaccessible to any other function in the program. Viewing this situation at a higher level, we have created an abstraction of a bank account that manages its own internals but behaves in a way that models accounts in the world: it changes over time based on its own history of withdrawal requests.
这样， `withdraw` 的每个实例都保持其自己的平衡状态，但程序中的任何其他函数都无法访问该状态。从更高的层次来观察这种情况，我们创建了一个银行账户的抽象，它管理自己的内部，但行为方式与世界上的账户一样：它基于其自身的撤销请求历史而随时间改变。

## 2.4.6  The Cost of Non-Local Assignment 2.4.6 异地派遣的成本

Our environment model of computation cleanly extends to explain the effects of non-local assignment. However, non-local assignment introduces some important nuances in the way we think about names and values.
我们的计算环境模型清晰地扩展到解释非本地赋值的影响。然而，非本地赋值在我们考虑名称和值的方式上引入了一些重要的细微差别。

Previously, our values did not change; only our names and bindings changed. When two names `a` and `b` were both bound to the value 4, it did not matter whether they were bound to the same 4 or different 4's. As far as we could tell, there was only one 4 object that never changed.
以前，我们的价值观没有改变;只是我们的名字和绑定改变了。当两个名字 `a` 和 `b` 都被绑定到值4时，它们被绑定到相同的4还是不同的4并不重要。据我们所知，只有一个物体从未改变过。

However, functions with state do not behave this way. When two names `wd` and `wd2` are both bound to a `withdraw` function, it *does* matter whether they are bound to the same function or different instances of that function. Consider the following example, which contrasts the one we just analyzed. In this case, calling the function named by `wd2` did change the value of the function named by `wd`, because both names refer to the same function.
但是，具有状态的函数不会这样做。当两个名称 `wd` 和 `wd2` 都绑定到 `withdraw` 函数时，它们是绑定到同一个函数还是该函数的不同实例并不重要。考虑下面的例子，它与我们刚才分析的例子形成对比。在本例中，调用以 `wd2` 命名的函数确实更改了以 `wd` 命名的函数的值，因为这两个名称引用的是同一个函数。


It is not unusual for two names to co-refer to the same value in the world, and so it is in our programs. But, as values change over time, we must be very careful to understand the effect of a change on other names that might refer to those values.
在世界上，两个名称共同引用同一个值并不罕见，在我们的程序中也是如此。但是，由于值会随时间而变化，我们必须非常小心地了解变化对可能引用这些值的其他名称的影响。

The key to correctly analyzing code with non-local assignment is to remember that only function calls can introduce new frames. Assignment statements always change bindings in existing frames. In this case, unless `make_withdraw` is called twice, there can be only one binding for `balance`.
正确分析具有非本地赋值的代码的关键是要记住，只有函数调用才能引入新帧。赋值语句总是更改现有框架中的绑定。在这种情况下，除非 `make_withdraw` 被调用两次，否则 `balance` 只能有一个绑定。

**Sameness and change.** These subtleties arise because, by introducing non-pure functions that change the non-local environment, we have changed the nature of expressions. An expression that contains only pure function calls is *referentially transparent*; its value does not change if we substitute one of its subexpression with the value of that subexpression.
相同和变化。这些微妙之处的出现是因为，通过引入改变非局部环境的非纯函数，我们已经改变了表达式的性质。只包含纯函数调用的表达式是引用透明的;如果我们用它的一个子表达式的值替换它的那个子表达式的值，它的值不会改变。

Re-binding operations violate the conditions of referential transparency because they do more than return a value; they change the environment. When we introduce arbitrary re-binding, we encounter a thorny epistemological issue: what it means for two values to be the same. In our environment model of computation, two separately defined functions are not the same, because changes to one may not be reflected in the other.
重新绑定操作违反了引用透明的条件，因为它们不仅仅返回一个值;它们改变了环境。当我们引入任意重新绑定时，我们遇到了一个棘手的认识论问题：两个值相同意味着什么。在我们的计算环境模型中，两个单独定义的函数并不相同，因为对一个函数的更改可能不会反映在另一个函数中。

In general, so long as we never modify data objects, we can regard a compound data object to be precisely the totality of its pieces. For example, a rational number is determined by giving its numerator and its denominator. But this view is no longer valid in the presence of change, where a compound data object has an "identity" that is something different from the pieces of which it is composed. A bank account is still "the same" bank account even if we change the balance by making a withdrawal; conversely, we could have two bank accounts that happen to have the same balance, but are different objects.
一般来说，只要我们从不修改数据对象，我们就可以将复合数据对象看作是其各个部分的集合。例如，一个有理数是通过给出它的分子和分母来确定的。但是，这种观点在发生变化时不再有效，因为复合数据对象的“身份”与组成它的数据块不同。一个银行账户仍然是“相同的”银行账户，即使我们通过取款改变了余额;相反，我们可能有两个银行帐户，它们碰巧具有相同的余额，但是是不同的对象。

Despite the complications it introduces, non-local assignment is a powerful tool for creating modular programs. Different parts of a program, which correspond to different environment frames, can evolve separately throughout program execution. Moreover, using functions with local state, we are able to implement mutable data types. In fact, we can implement abstract data types that are equivalent to the built-in `list` and `dict` types introduced above.
尽管它引入了复杂性，但非局部赋值是创建模块化程序的一个强大工具。对应于不同环境框架的程序的不同部分可以在整个程序执行过程中单独地演进。此外，使用具有局部状态的函数，我们能够实现可变数据类型。实际上，我们可以实现与上面介绍的内置 `list` 和 `dict` 类型等效的抽象数据类型。

## 2.4.7  Implementing Lists and Dictionaries 2.4.7 实现列表和字典

The Python language does not give us access to the implementation of lists, only to the sequence abstraction and mutation methods built into the language. To understand how a mutable list could be represented using functions with local state, we will now develop an implementation of a mutable linked list.
Python语言并没有给予我们访问列表的实现，只允许我们访问内置在语言中的序列抽象和变异方法。为了理解如何使用具有局部状态的函数来表示可变列表，我们现在将开发可变链表的实现。

We will represent a mutable linked list by a function that has a linked list as its local state. Lists need to have an identity, like any mutable value. In particular, we cannot use `None` to represent an empty mutable list, because two empty lists are not identical values (e.g., appending to one does not append to the other), but `None is None`. On the other hand, two different functions that each have `empty` as their local state will suffice to distinguish two empty lists.
我们将用一个函数来表示一个可变链表，该函数将一个链表作为其本地状态。列表需要有一个标识，就像任何可变值一样。特别地，我们不能使用 `None` 来表示空的可变列表，因为两个空列表不是相同的值（例如，附加到一个不附加到另一个），而是 `None is None` 。另一方面，各自具有 `empty` 作为其局部状态的两个不同函数将足以区分两个空列表。

If a mutable linked list is a function, what arguments does it take? The answer exhibits a general pattern in programming: the function is a dispatch function and its arguments are first a message, followed by additional arguments to parameterize that method. This message is a string naming what the function should do. Dispatch functions are effectively many functions in one: the message determines the behavior of the function, and the additional arguments are used in that behavior.
如果一个可变链表是一个函数，它需要什么参数？答案展示了编程的一般模式：该函数是调度函数，并且其自变量首先是消息，随后是用于参数化该方法的附加自变量。此消息是一个字符串，用于命名函数应执行的操作。调度功能实际上是集多种功能于一体：消息确定函数的行为，并且在该行为中使用附加参数。

Our mutable list will respond to five different messages: `len`, `getitem`, `push_first`, `pop_first`, and `str`. The first two implement the behaviors of the sequence abstraction. The next two add or remove the first element of the list. The final message returns a string representation of the whole linked list.
我们的可变列表将响应五种不同的消息：编号0#、编号1#、编号2#、编号3#和编号4#。前两个实现了序列抽象的行为。接下来的两个函数添加或删除列表的第一个元素。最后一条消息返回整个链表的字符串表示形式。

```
>>> def mutable_link():
        """Return a functional implementation of a mutable linked list."""
        contents = empty
        def dispatch(message, value=None):
            nonlocal contents
            if message == 'len':
                return len_link(contents)
            elif message == 'getitem':
                return getitem_link(contents, value)
            elif message == 'push_first':
                contents = link(value, contents)
            elif message == 'pop_first':
                f = first(contents)
                contents = rest(contents)
                return f
            elif message == 'str':
                return join_link(contents, ", ")
        return dispatch
```

We can also add a convenience function to construct a functionally implemented linked list from any built-in sequence, simply by adding each element in reverse order.
我们还可以添加一个方便的函数，从任何内置序列构造一个函数实现的链表，只需以相反的顺序添加每个元素。

```
>>> def to_mutable_link(source):
        """Return a functional list with the same contents as source."""
        s = mutable_link()
        for element in reversed(source):
            s('push_first', element)
        return s
```

In the definition above, the function `reversed` takes and returns an iterable value; it is another example of a function that processes sequences.
在上面的定义中，函数 `reversed` 获取并返回可迭代值;它是处理序列的函数的另一个例子。

At this point, we can construct a functionally implemented mutable linked lists. Note that the linked list itself is a function.
此时，我们可以构造一个功能上实现的可变链表。注意，链表本身就是一个函数。

```
>>> s = to_mutable_link(suits)
>>> type(s)
<class 'function'>
>>> print(s('str'))
heart, diamond, spade, club
```

In addition, we can pass messages to the list `s` that change its contents, for instance removing the first element.
此外，我们可以向列表 `s` 传递消息，以更改其内容，例如删除第一个元素。

```
>>> s('pop_first')
'heart'
>>> print(s('str'))
diamond, spade, club
```

In principle, the operations `push_first` and `pop_first` suffice to make arbitrary changes to a list. We can always empty out the list entirely and then replace its old contents with the desired result.
原则上，操作 `push_first` 和 `pop_first` 足以对列表进行任意改变。我们总是可以完全清空列表，然后用想要的结果替换它的旧内容。

**Message passing.** Given some time, we could implement the many useful mutation operations of Python lists, such as `extend` and `insert`. We would have a choice: we could implement them all as functions, which use the existing messages `pop_first` and `push_first` to make all changes. Alternatively, we could add additional `elif` clauses to the body of `dispatch`, each checking for a message (e.g., `'extend'`) and applying the appropriate change to `contents` directly.
传递信息。给我们一些时间，我们可以实现Python列表的许多有用的变异操作，比如 `extend` 和 `insert` 。我们会有一个选择：我们可以将它们全部实现为函数，这些函数使用现有的消息 `pop_first` 和 `push_first` 来进行所有更改。或者，我们可以向 `dispatch` 的主体添加额外的 `elif` 子句，每个子句检查一条消息（例如， `'extend'` ），并将适当的更改直接应用于 `contents` 。

This second approach, which encapsulates the logic for all operations on a data value within one function that responds to different messages, is a discipline called message passing. A program that uses message passing defines dispatch functions, each of which may have local state, and organizes computation by passing "messages" as the first argument to those functions. The messages are strings that correspond to particular behaviors.
第二种方法将对数据值的所有操作的逻辑封装在一个响应不同消息的函数中，这种方法称为消息传递。使用消息传递的程序定义了分派函数，每个函数都可以有本地状态，并通过将“消息”作为第一个参数传递给这些函数来组织计算。消息是对应于特定行为的字符串。

**Implementing Dictionaries.** We can also implement a value with similar behavior to a dictionary. In this case, we use a list of key-value pairs to store the contents of the dictionary. Each pair is a two-element list.
实现字典。我们还可以实现一个行为与字典类似的值。在本例中，我们使用键-值对列表来存储字典的内容。每一对都是一个两元素列表。

```
>>> def dictionary():
        """Return a functional implementation of a dictionary."""
        records = []
        def getitem(key):
            matches = [r for r in records if r[0] == key]
            if len(matches) == 1:
                key, value = matches[0]
                return value
        def setitem(key, value):
            nonlocal records
            non_matches = [r for r in records if r[0] != key]
            records = non_matches + [[key, value]]
        def dispatch(message, key=None, value=None):
            if message == 'getitem':
                return getitem(key)
            elif message == 'setitem':
                setitem(key, value)
        return dispatch
```

Again, we use the message passing method to organize our implementation. We have supported two messages: `getitem` and `setitem`. To insert a value for a key, we filter out any existing records with the given key, then add one. In this way, we are assured that each key appears only once in records. To look up a value for a key, we filter for the record that matches the given key. We can now use our implementation to store and retrieve values.
同样，我们使用消息传递方法来组织我们的实现。我们支持两种信息：编号0#和编号1#。要为键插入一个值，我们需要过滤掉任何具有给定键的现有记录，然后再添加一个。这样，我们就可以确保每个键在记录中只出现一次。为了查找键的值，我们筛选与给定键匹配的记录。现在我们可以使用我们的实现来存储和检索值。

```
>>> d = dictionary()
>>> d('setitem', 3, 9)
>>> d('setitem', 4, 16)
>>> d('getitem', 3)
9
>>> d('getitem', 4)
16
```

This implementation of a dictionary is *not* optimized for fast record lookup, because each call must filter through all records. The built-in dictionary type is considerably more efficient. The way in which it is implemented is beyond the scope of this text.
字典的这种实现没有针对快速记录查找进行优化，因为每个调用都必须筛选所有记录。内置字典类型的效率要高得多。其实施方式超出了本文的范围。

## 2.4.8  Dispatch Dictionaries 2.4.8 发送字典

The dispatch function is a general method for implementing a message passing interface for abstract data. To implement message dispatch, we have thus far used conditional statements to compare the message string to a fixed set of known messages.
调度函数是实现抽象数据消息传递接口的通用方法。为了实现消息调度，到目前为止，我们使用条件语句将消息字符串与一组固定的已知消息进行比较。

The built-in dictionary data type provides a general method for looking up a value for a key. Instead of using conditionals to implement dispatching, we can use dictionaries with string keys.
内置字典数据类型提供了查找键的值的通用方法。我们可以使用带有字符串键的字典来实现分派，而不是使用条件。

The mutable `account` data type below is implemented as a dictionary. It has a constructor `account` and selector `check_balance`, as well as functions to `deposit` or `withdraw` funds. Moreover, the local state of the account is stored in the dictionary alongside the functions that implement its behavior.
下面的可变 `account` 数据类型是作为字典实现的。它有一个构造器 `account` 和选择器 `check_balance` ，以及用于 `deposit` 或 `withdraw` 基金的函数。此外，帐户的本地状态与实现其行为的函数一起存储在字典中。



The name `dispatch` within the body of the `account` constructor is bound to a dictionary that contains the messages accepted by an account as keys. The *balance* is a number, while the messages *deposit* and *withdraw* are bound to functions. These functions have access to the `dispatch` dictionary, and so they can read and change the balance. By storing the balance in the dispatch dictionary rather than in the `account` frame directly, we avoid the need for `nonlocal` statements in `deposit` and `withdraw`.
`account` 构造函数体中的名称 `dispatch` 绑定到一个字典，该字典包含帐户作为键接受的消息。余额是一个数字，而消息存款和取款与函数绑定。这些函数可以访问 `dispatch` 字典，因此它们可以读取和更改余额。通过将余额存储在分派字典中而不是直接存储在 `account` 帧中，我们避免了对 `deposit` 和 `withdraw` 中的 `nonlocal` 语句的需要。

The operators `+=` and `-=` are shorthand in Python (and many other languages) for combined lookup and re-assignment. The last two lines below are equivalent.
运算符 `+=` 和 `-=` 是Python（和许多其他语言）中用于组合查找和重新赋值的简写。下面的最后两行是等效的。

```
>>> a = 2
>>> a = a + 1
>>> a += 1
```

## 2.4.9  Propagating Constraints 2.4.9 传播约束

Mutable data allows us to simulate systems with change, but also allows us to build new kinds of abstractions. In this extended example, we combine nonlocal assignment, lists, and dictionaries to build a *constraint-based system* that supports computation in multiple directions. Expressing programs as constraints is a type of *declarative programming*, in which a programmer declares the structure of a problem to be solved, but abstracts away the details of exactly how the solution to the problem is computed.
可变数据允许我们模拟变化的系统，但也允许我们构建新的抽象类型。在这个扩展示例中，我们将非局部赋值、列表和字典结合起来，构建一个基于约束的系统，支持多方向计算。将程序表达为约束是一种声明性编程，其中程序员声明要解决的问题的结构，但抽象出如何计算问题的解的细节。

Computer programs are traditionally organized as one-directional computations, which perform operations on pre-specified arguments to produce desired outputs. On the other hand, we often want to model systems in terms of relations among quantities. For example, we previously considered the ideal gas law, which relates the pressure (`p`), volume (`v`), quantity (`n`), and temperature (`t`) of an ideal gas via Boltzmann's constant (`k`):
计算机程序传统上被组织为单向计算，其对预先指定的自变量执行操作以产生期望的输出。另一方面，我们常常希望根据量之间的关系来建立系统模型。例如，我们之前考虑过理想气体定律，该定律通过玻尔兹曼常数（ `k` ）将理想气体的压力（ `p` ）、体积（ `v` ）、量（ `n` ）和温度（ `t` ）联系起来：

```
p * v = n * k * t
```

Such an equation is not one-directional. Given any four of the quantities, we can use this equation to compute the fifth. Yet translating the equation into a traditional computer language would force us to choose one of the quantities to be computed in terms of the other four. Thus, a function for computing the pressure could not be used to compute the temperature, even though the computations of both quantities arise from the same equation.
这样的等式不是单向的。给定任意四个量，我们可以用这个方程计算第五个量。然而，把这个方程翻译成传统的计算机语言，我们就不得不选择其中一个量来计算其他四个量。因此，计算压力的函数不能用于计算温度，即使两个量的计算来自同一个方程。

In this section, we sketch the design of a general model of linear relationships. We define primitive constraints that hold between quantities, such as an `adder(a, b, c)` constraint that enforces the mathematical relationship `a + b = c`.
在本节中，我们将简要介绍线性关系的一般模型的设计。我们定义了保持在量之间的基本约束，例如实施数学关系 `a + b = c` 的 `adder(a, b, c)` 约束。

We also define a means of combination, so that primitive constraints can be combined to express more complex relations. In this way, our program resembles a programming language. We combine constraints by constructing a network in which constraints are joined by connectors. A connector is an object that "holds" a value and may participate in one or more constraints.
我们还定义了一种组合的方法，这样原始约束就可以组合起来表达更复杂的关系。这样，我们的程序就像一门编程语言。我们通过构建一个网络来联合收割机约束，在该网络中约束由连接器连接。连接器是“保存”值的对象，可以参与一个或多个约束。

For example, we know that the relationship between Fahrenheit and Celsius temperatures is:
例如，我们知道华氏温度和摄氏温度之间的关系是：

```
9 * c = 5 * (f - 32)
```

This equation is a complex constraint between `c` and `f`. Such a constraint can be thought of as a network consisting of primitive `adder`, `multiplier`, and `constant` constraints.
此方程是 `c` 和 `f` 之间的复杂约束。这样的约束可以被认为是由基元 `adder` 、 `multiplier` 和 `constant` 约束组成的网络。

![constraints](/sicp-python/constraints.png)

In this figure, we see on the left a multiplier box with three terminals, labeled `a`, `b`, and `c`. These connect the multiplier to the rest of the network as follows: The `a` terminal is linked to a connector `celsius`, which will hold the Celsius temperature. The `b` terminal is linked to a connector `w`, which is also linked to a constant box that holds 9. The `c` terminal, which the multiplier box constrains to be the product of `a` and `b`, is linked to the `c` terminal of another multiplier box, whose `b` is connected to a constant 5 and whose `a` is connected to one of the terms in the sum constraint.
在此图中，我们在左侧看到一个乘法器框，它有三个端子，分别标记为 `a` 、 `b` 和 `c` 。它们将乘法器与网络的其余部分连接如下： `a` 端子连接到连接器 `celsius` ，该连接器将保持摄氏温度。 `b` 端子连接到连接器 `w` ，连接器 `w` 还连接到容纳9的常数箱。乘法器框约束为 `a` 和 `b` 的乘积的 `c` 端子链接到另一乘法器框的 `c` 端子，该另一乘法器框的 `b` 连接到常数5并且其 `a` 连接到和约束中的项之一。

Computation by such a network proceeds as follows: When a connector is given a value (by the user or by a constraint box to which it is linked), it awakens all of its associated constraints (except for the constraint that just awakened it) to inform them that it has a value. Each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector. If so, the box sets that connector, which then awakens all of its associated constraints, and so on. For instance, in conversion between Celsius and Fahrenheit, `w`, `x`, and `y` are immediately set by the constant boxes to 9, 5, and 32, respectively. The connectors awaken the multipliers and the adder, which determine that there is not enough information to proceed. If the user (or some other part of the network) sets the `celsius` connector to a value (say 25), the leftmost multiplier will be awakened, and it will set `u` to `25 * 9 = 225`. Then `u` awakens the second multiplier, which sets `v` to 45, and `v` awakens the adder, which sets the `fahrenheit` connector to 77.
然后 `u` 唤醒第二个乘法器，将 `v` 设置为45， `v` 唤醒加法器，将 `fahrenheit` 连接器设置为77。由这样的网络进行的计算如下：当连接器被赋予值（由用户或由其链接到的约束框）时，它将唤醒其所有关联约束（除了刚刚唤醒它的约束），以通知它们它具有值。然后，每个被唤醒的约束框轮询其连接器，以查看是否有足够的信息来确定连接器的值。如果是，则该框设置该连接器，然后唤醒其所有关联的约束条件，依此类推。例如，在摄氏度和华氏度之间的转换中，常量框会立即将 `w` 、 `x` 和 `y` 分别设置为9、5和32。连接器唤醒乘法器和加法器，乘法器和加法器确定没有足够的信息继续处理。如果用户（或网络的某个其他部分）将 `celsius` 连接器设置为某个值（例如25），则最左边的乘法器将被唤醒，并且它将 `u` 设置为 `25 * 9 = 225` 。

**Using the Constraint System.** To use the constraint system to carry out the temperature computation outlined above, we first create two named connectors, `celsius` and `fahrenheit`, by calling the `connector` constructor.
使用约束系统。为了使用约束系统来执行上面概述的温度计算，我们首先通过调用 `connector` 构造函数来创建两个命名连接器 `celsius` 和 `fahrenheit` 。

```
>>> celsius = connector('Celsius')
>>> fahrenheit = connector('Fahrenheit')
```

Then, we link these connectors into a network that mirrors the figure above. The function `converter` assembles the various connectors and constraints in the network.
然后，我们将这些连接器链接到一个网络中，该网络与上图完全相同。函数 `converter` 组合网络中的各种连接器和约束。

```
>>> def converter(c, f):
        """Connect c to f with constraints to convert from Celsius to Fahrenheit."""
        u, v, w, x, y = [connector() for _ in range(5)]
        multiplier(c, w, u)
        multiplier(v, x, u)
        adder(v, y, f)
        constant(w, 9)
        constant(x, 5)
        constant(y, 32)
>>> converter(celsius, fahrenheit)
```

We will use a message passing system to coordinate constraints and connectors. Constraints are dictionaries that do not hold local states themselves. Their responses to messages are non-pure functions that change the connectors that they constrain.
我们将使用消息传递系统来协调约束和连接器。约束是不保存本地状态本身的字典。它们对消息的响应是非纯函数，这些函数会更改它们所约束的连接器。

Connectors are dictionaries that hold a current value and respond to messages that manipulate that value. Constraints will not change the value of connectors directly, but instead will do so by sending messages, so that the connector can notify other constraints in response to the change. In this way, a connector represents a number, but also encapsulates connector behavior.
连接器是保存当前值并响应操作该值的消息的字典。约束不会直接更改连接器的值，而是通过发送消息来更改，以便连接器可以通知其他约束以响应更改。通过这种方式，连接器表示一个数字，但也封装了连接器的行为。

One message we can send to a connector is to set its value. Here, we (the `'user'`) set the value of `celsius` to 25.
我们可以发送给连接器的一条消息是设置它的值。这里，我们（ `'user'` ）将 `celsius` 的值设置为25。

```
>>> celsius['set_val']('user', 25)
Celsius = 25
Fahrenheit = 77.0
```

Not only does the value of `celsius` change to 25, but its value propagates through the network, and so the value of `fahrenheit` is changed as well. These changes are printed because we named these two connectors when we constructed them.
不仅 `celsius` 的值改变为25，而且其值通过网络传播，因此 `fahrenheit` 的值也改变。打印这些更改是因为我们在构造这两个连接器时对其进行了命名。

Now we can try to set `fahrenheit` to a new value, say 212.
现在我们可以尝试将 `fahrenheit` 设置为一个新值，比如212。

```
>>> fahrenheit['set_val']('user', 212)
Contradiction detected: 77.0 vs 212
```

The connector complains that it has sensed a contradiction: Its value is 77.0, and someone is trying to set it to 212. If we really want to reuse the network with new values, we can tell `celsius` to forget its old value:
连接器抱怨它感觉到矛盾：它的值是77.0，有人试图将其设置为212。如果我们真的想用新值重新使用网络，我们可以告诉 `celsius` 忘记它的旧值：

```
>>> celsius['forget']('user')
Celsius is forgotten
Fahrenheit is forgotten
```

The connector `celsius` finds that the `user`, who set its value originally, is now retracting that value, so `celsius` agrees to lose its value, and it informs the rest of the network of this fact. This information eventually propagates to `fahrenheit`, which now finds that it has no reason for continuing to believe that its own value is 77. Thus, it also gives up its value.
连接器 `celsius` 发现最初设置其值的连接器 `user` 现在撤销该值，因此连接器 `celsius` 同意丢失其值，并且连接器 `celsius` 将该事实通知网络的其余部分。这个信息最终传播到 `fahrenheit` ， `fahrenheit` 现在发现它没有理由继续相信它自己的值是77。因此，它也放弃了它的价值。

Now that `fahrenheit` has no value, we are free to set it to 212:
现在 `fahrenheit` 没有值了，我们可以将其设置为212：

```
>>> fahrenheit['set_val']('user', 212)
Fahrenheit = 212
Celsius = 100.0
```

This new value, when propagated through the network, forces `celsius` to have a value of 100. We have used the very same network to compute `celsius` given `fahrenheit` and to compute `fahrenheit` given `celsius`. This non-directionality of computation is the distinguishing feature of constraint-based systems.
这个新值在通过网络传播时强制 `celsius` 具有值100。我们使用了完全相同的网络，在给定 `fahrenheit` 的情况下计算 `celsius` ，在给定 `celsius` 的情况下计算 `fahrenheit` 。这种计算的无方向性是基于约束的系统的显著特征。

**Implementing the Constraint System.** As we have seen, connectors are dictionaries that map message names to function and data values. We will implement connectors that respond to the following messages:
实施约束系统。正如我们所看到的，连接器是将消息名称映射到函数和数据值的字典。我们将实现响应以下消息的连接器：

- `connector['set_val'](source, value)` indicates that the `source` is requesting the connector to set its current value to `value`.
    `connector['set_val'](source, value)` 表示 `source` 正在请求连接器将其当前值设置为 `value` 。
- `connector['has_val']()` returns whether the connector already has a value.
    `connector['has_val']()` 返回连接器是否已有值。
- `connector['val']` is the current value of the connector.
    `connector['val']` 是连接器的当前值。
- `connector['forget'](source)` tells the connector that the `source` is requesting it to forget its value.
    `connector['forget'](source)` 告诉连接器 `source` 正在请求它忘记它的值。
- `connector['connect'](source)` tells the connector to participate in a new constraint, the `source`.
    `connector['connect'](source)` 通知连接器加入新约束 `source` 。

Constraints are also dictionaries, which receive information from connectors by means of two messages:
约束也是字典，它通过两条消息从连接器接收信息：

- `constraint['new_val']()` indicates that some connector that is connected to the constraint has a new value.
    `constraint['new_val']()` 表示连接到约束的某个接头具有新值。
- `constraint['forget']()` indicates that some connector that is connected to the constraint has forgotten its value.
    `constraint['forget']()` 表示连接到约束的某个连接器忘记了其值。

When constraints receive these messages, they propagate them appropriately to other connectors.
当约束接收到这些消息时，它们会将这些消息适当地传播到其他连接器。

The `adder` function constructs an adder constraint over three connectors, where the first two must add to the third: `a + b = c`. To support multidirectional constraint propagation, the adder must also specify that it subtracts `a` from `c` to get `b` and likewise subtracts `b` from `c` to get `a`.
`adder` 函数在三个连接器上构造加法器约束，其中前两个必须与第三个相加：一号。为了支持多方向约束传播，加法器还必须指定它从 `c` 减去 `a` 以得到 `b` ，并且类似地从 `c` 减去 `b` 以得到 `a` 。

```
>>> from operator import add, sub
>>> def adder(a, b, c):
        """The constraint that a + b = c."""
        return make_ternary_constraint(a, b, c, add, sub, sub)
```

We would like to implement a generic ternary (three-way) constraint, which uses the three connectors and three functions from `adder` to create a constraint that accepts `new_val` and `forget` messages. The response to messages are local functions, which are placed in a dictionary called `constraint`.
我们希望实现一个通用的三元（三路）约束，它使用 `adder` 中的三个连接器和三个函数来创建一个接受 `new_val` 和 `forget` 消息的约束。对消息的响应是本地函数，它们被放置在名为 `constraint` 的字典中。

```
>>> def make_ternary_constraint(a, b, c, ab, ca, cb):
        """The constraint that ab(a,b)=c and ca(c,a)=b and cb(c,b) = a."""
        def new_value():
            av, bv, cv = [connector['has_val']() for connector in (a, b, c)]
            if av and bv:
                c['set_val'](constraint, ab(a['val'], b['val']))
            elif av and cv:
                b['set_val'](constraint, ca(c['val'], a['val']))
            elif bv and cv:
                a['set_val'](constraint, cb(c['val'], b['val']))
        def forget_value():
            for connector in (a, b, c):
                connector['forget'](constraint)
        constraint = {'new_val': new_value, 'forget': forget_value}
        for connector in (a, b, c):
            connector['connect'](constraint)
        return constraint
```

The dictionary called `constraint` is a dispatch dictionary, but also the constraint object itself. It responds to the two messages that constraints receive, but is also passed as the `source` argument in calls to its connectors.
名为 `constraint` 的字典是调度字典，但也是约束对象本身。它响应约束接收的两条消息，但也作为 `source` 参数在调用其连接器时传递。

The constraint's local function `new_value` is called whenever the constraint is informed that one of its connectors has a value. This function first checks to see if both `a` and `b` have values. If so, it tells `c` to set its value to the return value of function `ab`, which is `add` in the case of an `adder`. The constraint passes *itself* (`constraint`) as the `source` argument of the connector, which is the adder object. If `a` and `b` do not both have values, then the constraint checks `a` and `c`, and so on.
每当约束被告知其连接器之一具有值时，就会调用约束的局部函数 `new_value` 。此函数首先检查 `a` 和 `b` 是否都有值。如果是，它告诉 `c` 将其值设置为函数 `ab` 的返回值，在 `adder` 的情况下为 `add` 。约束将自身（ `constraint` ）作为connector（即adder对象）的 `source` 参数传递。如果 `a` 和 `b` 不都有值，则约束检查 `a` 和 `c` ，依此类推。

If the constraint is informed that one of its connectors has forgotten its value, it requests that all of its connectors now forget their values. (Only those values that were set by this constraint are actually lost.)
如果约束被告知它的一个连接器忘记了它的值，它会请求它的所有连接器现在都忘记它们的值。(Only由该约束设置的那些值实际上丢失了）。

A `multiplier` is very similar to an `adder`.
`multiplier` 与 `adder` 非常相似。

```
>>> from operator import mul, truediv
>>> def multiplier(a, b, c):
        """The constraint that a * b = c."""
        return make_ternary_constraint(a, b, c, mul, truediv, truediv)
```

A constant is a constraint as well, but one that is never sent any messages, because it involves only a single connector that it sets on construction.
常量也是一个约束，但它从不发送任何消息，因为它只涉及它在构造时设置的单个连接器。

```
>>> def constant(connector, value):
        """The constraint that connector = value."""
        constraint = {}
        connector['set_val'](constraint, value)
        return constraint
```

These three constraints are sufficient to implement our temperature conversion network.
这三个约束足以实现我们的温度转换网络。

**Representing connectors.** A connector is represented as a dictionary that contains a value, but also has response functions with local state. The connector must track the `informant` that gave it its current value, and a list of `constraints` in which it participates.
表示连接器。连接器被表示为一个字典，它包含一个值，但也具有带有本地状态的响应函数。连接器必须跟踪为其提供当前值的 `informant` ，以及它参与的 `constraints` 列表。

The constructor `connector` has local functions for setting and forgetting values, which are the responses to messages from constraints.
构造函数 `connector` 具有用于设置和遗忘值的局部函数，这些值是对来自约束的消息的响应。

```
>>> def connector(name=None):
        """A connector between constraints."""
        informant = None
        constraints = []
        def set_value(source, value):
            nonlocal informant
            val = connector['val']
            if val is None:
                informant, connector['val'] = source, value
                if name is not None:
                    print(name, '=', value)
                inform_all_except(source, 'new_val', constraints)
            else:
                if val != value:
                    print('Contradiction detected:', val, 'vs', value)
        def forget_value(source):
            nonlocal informant
            if informant == source:
                informant, connector['val'] = None, None
                if name is not None:
                    print(name, 'is forgotten')
                inform_all_except(source, 'forget', constraints)
        connector = {'val': None,
                     'set_val': set_value,
                     'forget': forget_value,
                     'has_val': lambda: connector['val'] is not None,
                     'connect': lambda source: constraints.append(source)}
        return connector
```

A connector is again a dispatch dictionary for the five messages used by constraints to communicate with connectors. Four responses are functions, and the final response is the value itself.
连接器也是约束用来与连接器通信的五条消息的调度字典。4个响应是函数，最后一个响应是值本身。

The local function `set_value` is called when there is a request to set the connector's value. If the connector does not currently have a value, it will set its value and remember as `informant` the source constraint that requested the value to be set. Then the connector will notify all of its participating constraints except the constraint that requested the value to be set. This is accomplished using the following iterative function.
当请求设置连接器的值时，调用本地函数 `set_value` 。如果连接器当前没有值，它将设置其值，并将请求设置值的源约束记为 `informant` 。然后，连接器将通知除请求设置值的约束之外的所有参与约束。这是使用以下迭代函数完成的。

```
>>> def inform_all_except(source, message, constraints):
        """Inform all constraints of the message, except source."""
        for c in constraints:
            if c != source:
                c[message]()
```

If a connector is asked to forget its value, it calls the local function `forget-value`, which first checks to make sure that the request is coming from the same constraint that set the value originally. If so, the connector informs its associated constraints about the loss of the value.
如果连接器被要求忘记它的值，它调用本地函数 `forget-value` ，该函数首先检查以确保请求来自最初设置该值的同一个约束。如果是，连接器将通知其关联的约束有关值丢失的情况。

The response to the message `has_val` indicates whether the connector has a value. The response to the message `connect` adds the source constraint to the list of constraints.
对消息 `has_val` 的响应指示连接器是否具有值。对消息 `connect` 的响应将源约束添加到约束列表。

The constraint program we have designed introduces many ideas that will appear again in object-oriented programming. Constraints and connectors are both abstractions that are manipulated through messages. When the value of a connector is changed, it is changed via a message that not only changes the value, but validates it (checking the source) and propagates its effects (informing other constraints). In fact, we will use a similar architecture of dictionaries with string-valued keys and functional values to implement an object-oriented system later in this chapter.
我们设计的约束程序引入了许多在面向对象编程中还会出现的思想。约束和连接器都是通过消息操作的抽象。当连接器的值被更改时，它通过一条消息进行更改，该消息不仅更改值，而且验证它（检查源）并传播其效果（通知其他约束）。实际上，我们将在本章后面使用类似的字典体系结构，使用字符串值键和函数值来实现面向对象系统。