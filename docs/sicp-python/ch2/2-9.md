# 2.8 é€’å½’å¯¹è±¡

:::info
è¯‘è€…ï¼š[Mancuoj](https://github.com/mancuoj)

æ¥æºï¼š[2.9 Recursive Objects](http://composingprograms.com/pages/29-recursive-objects.html)

å¯¹åº”ï¼šHW 05

:::





å¯¹è±¡å¯ä»¥æ‹¥æœ‰å…¶ä»–å¯¹è±¡ä½œä¸ºå±æ€§å€¼ã€‚å½“æŸä¸ªç±»çš„å¯¹è±¡å…·æœ‰åŒä¸€ä¸ªç±»çš„å±æ€§å€¼æ—¶ï¼Œå®ƒå°±æ˜¯é€’å½’å¯¹è±¡ï¼ˆrecursive objectï¼‰ã€‚

## 2.9.1 é“¾è¡¨ç±»

æœ¬ç« å‰é¢ä»‹ç»çš„é“¾è¡¨ï¼ˆlinked listï¼‰ï¼Œæ˜¯ç”±ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†ç»„æˆã€‚å®ƒçš„å…¶ä½™éƒ¨åˆ†æœ¬èº«å°±æ˜¯ä¸€ä¸ªé“¾è¡¨ --> è¿™å°±æ˜¯ä¸€ä¸ªé€’å½’çš„å®šä¹‰ã€‚ç©ºé“¾è¡¨æ˜¯é“¾è¡¨çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œæ²¡æœ‰ç¬¬ä¸€ä¸ªå…ƒç´ æˆ–å…¶ä½™å…ƒç´ ã€‚é“¾è¡¨æ˜¯ä¸€ä¸ªåºåˆ—ï¼šå®ƒå…·æœ‰æœ‰é™çš„é•¿åº¦ï¼Œå¹¶æ”¯æŒæŒ‰ç´¢å¼•é€‰æ‹©å…ƒç´ ã€‚

ç°åœ¨æˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªå…·æœ‰ç›¸åŒè¡Œä¸ºçš„ç±»ã€‚åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç‰¹æ®Šçš„æ–¹æ³•åæ¥å®šä¹‰å®ƒçš„è¡Œä¸ºï¼Œè¿™äº›æ–¹æ³•åå…è®¸æˆ‘ä»¬çš„ç±»ä½¿ç”¨ Python ä¸­å†…ç½®çš„ `len` å‡½æ•°å’Œå…ƒç´ é€‰æ‹©æ“ä½œç¬¦ï¼ˆ`[]` æˆ– `operator.getitem`ï¼‰ã€‚è¿™äº›å†…ç½®å‡½æ•°ä¼šè°ƒç”¨ç±»çš„ç‰¹æ®Šæ–¹æ³•åï¼šé•¿åº¦ç”± `__len__` è¿›è¡Œè®¡ç®—ï¼Œå…ƒç´ ç”± `__getitem__` è¿›è¡Œé€‰æ‹©ã€‚ç©ºé“¾è¡¨ç”±ä¸€ä¸ªç©ºå…ƒç»„ï¼ˆtupleï¼‰è¡¨ç¤ºï¼Œå®ƒçš„é•¿åº¦ä¸º 0 ä¸”ä¸åŒ…å«å…ƒç´ ã€‚

```py
>>> class Link:
        """ç”±ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå…¶ä½™éƒ¨åˆ†ç»„æˆçš„é“¾è¡¨"""
        empty = ()
        def __init__(self, first, rest=empty):
            assert rest is Link.empty or isinstance(rest, Link)
            self.first = first
            self.rest = rest
        def __getitem__(self, i):
            if i == 0:
                return self.first
            else:
                return self.rest[i-1]
        def __len__(self):
            return 1 + len(self.rest)
            
>>> s = Link(3, Link(4, Link(5)))
>>> len(s)
3
>>> s[1]
4
```

å®é™…ä¸Šï¼Œ`__len__` å’Œ `__getitem__` çš„å®šä¹‰æ˜¯é€’å½’çš„ã€‚åœ¨åº”ç”¨äºç”¨æˆ·å®šä¹‰çš„å¯¹è±¡å‚æ•°æ—¶ï¼ŒPython å†…ç½®çš„å‡½æ•° `len` è°ƒç”¨äº†ä¸€ä¸ªåä¸º `__len__` çš„æ–¹æ³•ã€‚åŒæ ·ï¼Œå…ƒç´ é€‰æ‹©æ“ä½œç¬¦è°ƒç”¨äº†åä¸º `__getitem__` çš„æ–¹æ³•ã€‚å› æ­¤ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•çš„ä¸»ä½“ä¼šé—´æ¥åœ°è°ƒç”¨å®ƒä»¬è‡ªå·±ã€‚å¯¹äº `__len__` ï¼Œå½“ `self.rest` è®¡ç®—ä¸ºç©ºå…ƒç»„ `Link.empty` æ—¶ï¼ˆé•¿åº¦ä¸º 0ï¼‰ï¼Œå°±è¾¾åˆ°åŸºçº¿æ¡ä»¶ï¼ˆbase caseï¼‰ã€‚

The built-in `isinstance` function returns whether the first argument has a type that is or inherits from the second argument. `isinstance(rest, Link)` is true if `rest` is a `Link` instance or an instance of some sub-class of `Link`.

å†…ç½®çš„ `isinstance` å‡½æ•°è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°çš„ç±»å‹æ˜¯ç¬¬äºŒä¸ªå‚æ•°çš„ç±»å‹ï¼Œæˆ–æ˜¯ä»ç¬¬äºŒä¸ªå‚æ•°ç»§æ‰¿çš„ç±»å‹ã€‚å¦‚æœ `rest` æ˜¯ `Link` å®ä¾‹æˆ– `Link` çš„æŸä¸ªå­ç±»çš„å®ä¾‹ï¼Œåˆ™ `isinstance(rest, Link)` ä¸ºçœŸã€‚

æˆ‘ä»¬çš„å®ç°å·²ç»å®Œæˆï¼Œä½†æ˜¯ `Link` ç±»çš„å®ä¾‹ç›®å‰å¾ˆéš¾æ£€æŸ¥ã€‚ä¸ºäº†å¸®åŠ©è°ƒè¯•ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°æ¥å°† `Link` è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¡¨è¾¾å¼ã€‚

```py
>>> def link_expression(s):
        """è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸² s"""
        if s.rest is Link.empty:
            rest = ''
        else:
            rest = ', ' + link_expression(s.rest)
        return 'Link({0}{1})'.format(s.first, rest)
    
>>> link_expression(s)
'Link(3, Link(4, Link(5)))'
```

This way of displaying an `Link` is so convenient that we would like to use it whenever an `Link` instance is displayed. We can ensure this behavior by setting the `link_expression` function as the value of the special class attribute `__repr__`. Python displays instances of user-defined classes by invoking their `__repr__` method.

è¿™ç§æ–¹ä¾¿åœ°æ˜¾ç¤º `Link` çš„æ–¹æ³•å¯ä»¥åœ¨æ¯æ¬¡å±•ç¤º `Link` å®ä¾‹æ—¶ä½¿ç”¨ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°† `link_expression` å‡½æ•°è®¾ç½®ä¸ºç‰¹æ®Šç±»å±æ€§ `__repr__` çš„å€¼æ¥ç¡®ä¿è¿™ç§è¡Œä¸ºã€‚Python ä¼šé€šè¿‡è°ƒç”¨ç”¨æˆ·å®šä¹‰ç±»åœ° `__repr__` æ–¹æ³•æ¥å±•ç¤ºå®ƒä»¬çš„å®ä¾‹ã€‚

```py
>>> Link.__repr__ = link_expression
>>> s
Link(3, Link(4, Link(5)))
```

The `Link` class has the closure property. Just as an element of a list can itself be a list, a `Link` can contain a `Link` as its `first` element.

`Link` ç±»å…·æœ‰é—­åŒ…å±æ€§ã€‚å°±åƒåˆ—è¡¨çš„å…ƒç´ æœ¬èº«å¯ä»¥æ˜¯åˆ—è¡¨ä¸€æ ·ï¼Œ `Link` å¯ä»¥åŒ…å« `Link` ä½œä¸ºå…¶ `first` å…ƒç´ ã€‚

```py
>>> s_first = Link(s, Link(6))
>>> s_first
Link(Link(3, Link(4, Link(5))), Link(6))
```

The `s_first` linked list has only two elements, but its first element is a linked list with three elements.

`s_first` é“¾è¡¨åªæœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œä½†å®ƒçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæœ‰ä¸‰ä¸ªå…ƒç´ çš„é“¾è¡¨ã€‚

```py
>>> len(s_first)
2
>>> len(s_first[0])
3
>>> s_first[0][2]
5
```

Recursive functions are particularly well-suited to manipulate linked lists. For instance, the recursive `extend_link` function builds a linked list containing the elements of one `Link` instance `s` followed by the elements of another `Link` instance `t`. Installing this function as the `__add__` method of the `Link` class emulates the addition behavior of a built-in list.

é€’å½’å‡½æ•°ç‰¹åˆ«é€‚åˆäºæ“ä½œé“¾è¡¨ã€‚ä¾‹å¦‚ï¼Œé€’å½’ `extend_link` å‡½æ•°æ„å»ºä¸€ä¸ªé“¾è¡¨ï¼Œè¯¥é“¾è¡¨åŒ…å«ä¸€ä¸ª `Link` å®ä¾‹ `s` çš„å…ƒç´ ï¼Œå…¶åè·Ÿéšå¦ä¸€ä¸ª `Link` å®ä¾‹ `t` çš„å…ƒç´ ã€‚å°†æ­¤å‡½æ•°å®‰è£…ä¸º `Link` ç±»çš„ `__add__` æ–¹æ³•å°†æ¨¡æ‹Ÿå†…ç½®åˆ—è¡¨çš„æ·»åŠ è¡Œä¸ºã€‚

```py
>>> def extend_link(s, t):
        if s is Link.empty:
            return t
        else:
            return Link(s.first, extend_link(s.rest, t))
>>> extend_link(s, s)
Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))
>>> Link.__add__ = extend_link
>>> s + s
Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))
```

Rather than list comprehensions, one linked list can be generated from another using two higher-order functions: `map_link` and `filter_link`. The `map_link` function defined below applies a function `f` to each element of a linked list `s` and constructs a linked list containing the results.

ä¸åˆ—è¡¨è§£æä¸åŒï¼Œå¯ä»¥ä½¿ç”¨ä¸¤ä¸ªé«˜é˜¶å‡½æ•°ä»ä¸€ä¸ªé“¾è¡¨ç”Ÿæˆå¦ä¸€ä¸ªé“¾è¡¨ï¼šç¼–å·0#å’Œç¼–å·1#ã€‚ä¸‹é¢å®šä¹‰çš„ `map_link` å‡½æ•°å°†å‡½æ•° `f` åº”ç”¨äºé“¾è¡¨ `s` çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶æ„é€ åŒ…å«ç»“æœçš„é“¾è¡¨ã€‚

```py
>>> def map_link(f, s):
        if s is Link.empty:
            return s
        else:
            return Link(f(s.first), map_link(f, s.rest))
>>> map_link(square, s)
Link(9, Link(16, Link(25)))
```

The `filter_link` function returns a linked list containing all elements of a linked list `s` for which `f` returns a true value. The combination of `map_link` and `filter_link` can express the same logic as a list comprehension.

`filter_link` å‡½æ•°è¿”å›åŒ…å«é“¾è¡¨ `s` çš„æ‰€æœ‰å…ƒç´ çš„é“¾è¡¨ï¼Œå…¶ä¸­ `f` ä¸ºé“¾è¡¨ `s` è¿”å›çœŸå€¼ã€‚ `map_link` å’Œ `filter_link` çš„ç»„åˆå¯ä»¥è¡¨è¾¾ä¸åˆ—è¡¨è§£æç›¸åŒçš„é€»è¾‘ã€‚

```py
>>> def filter_link(f, s):
        if s is Link.empty:
            return s
        else:
            filtered = filter_link(f, s.rest)
            if f(s.first):
                return Link(s.first, filtered)
            else:
                return filtered
>>> odd = lambda x: x % 2 == 1
>>> map_link(square, filter_link(odd, s))
Link(9, Link(25))
>>> [square(x) for x in [3, 4, 5] if odd(x)]
[9, 25]
```

The `join_link` function recursively constructs a string that contains the elements of a linked list seperated by some `separator` string. The result is much more compact than the output of `link_expression`.

`join_link` å‡½æ•°é€’å½’æ„é€ ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯¥å­—ç¬¦ä¸²åŒ…å«ç”±æŸä¸ª `separator` å­—ç¬¦ä¸²åˆ†éš”çš„é“¾è¡¨å…ƒç´ ã€‚ç»“æœæ¯” `link_expression` çš„è¾“å‡ºè¦ç´§å‡‘å¾—å¤šã€‚

```py
>>> def join_link(s, separator):
        if s is Link.empty:
            return ""
        elif s.rest is Link.empty:
            return str(s.first)
        else:
            return str(s.first) + separator + join_link(s.rest, separator)
>>> join_link(s, ", ")
'3, 4, 5'
```

**Recursive Construction.** Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.

é€’å½’æ„é€ ã€‚é“¾è¡¨åœ¨ä»¥å¢é‡æ–¹å¼æ„é€ åºåˆ—æ—¶ç‰¹åˆ«æœ‰ç”¨ï¼Œè¿™ç§æƒ…å†µåœ¨é€’å½’è®¡ç®—ä¸­ç»å¸¸å‡ºç°ã€‚

The `count_partitions` function from Chapter 1 counted the number of ways to partition an integer `n` using parts up to size `m` via a tree-recursive process. With sequences, we can also enumerate these partitions explicitly using a similar process.

ç¬¬1ç« ä¸­çš„ `count_partitions` å‡½æ•°é€šè¿‡æ ‘é€’å½’è¿‡ç¨‹è®¡ç®—äº†ä½¿ç”¨å¤§å°ä¸º `m` çš„éƒ¨åˆ†åˆ’åˆ†æ•´æ•° `n` çš„æ–¹æ³•æ•°ã€‚å¯¹äºåºåˆ—ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„è¿‡ç¨‹æ˜¾å¼æšä¸¾è¿™äº›åˆ†åŒºã€‚

We follow the same recursive analysis of the problem as we did while counting: partitioning `n` using integers up to `m` involves either

æˆ‘ä»¬éµå¾ªä¸è®¡æ•°æ—¶ç›¸åŒçš„é—®é¢˜é€’å½’åˆ†æï¼šä½¿ç”¨å¤§äºç­‰äº `m` çš„æ•´æ•°å¯¹ `n` è¿›è¡Œåˆ†åŒºåŒ…æ‹¬

1. partitioning `n-m` using integers up to `m`, or
    ä½¿ç”¨æœ€å¤§ä¸º `m` çš„æ•´æ•°å¯¹ `n-m` è¿›è¡Œåˆ†åŒºï¼Œæˆ–è€…
2. partitioning `n` using integers up to `m-1`.
    ä½¿ç”¨ç›´åˆ° `m-1` çš„æ•´æ•°å¯¹ `n` è¿›è¡Œåˆ†åŒºã€‚

For base cases, we find that 0 has an empty partition, while partitioning a negative integer or using parts smaller than 1 is impossible.

å¯¹äºåŸºæœ¬æƒ…å†µï¼Œæˆ‘ä»¬å‘ç°0æœ‰ä¸€ä¸ªç©ºåˆ†åŒºï¼Œè€Œåˆ†åŒºè´Ÿæ•´æ•°æˆ–ä½¿ç”¨å°äº1çš„éƒ¨åˆ†æ˜¯ä¸å¯èƒ½çš„ã€‚

```py
>>> def partitions(n, m):
        """Return a linked list of partitions of n using parts of up to m.
        Each partition is represented as a linked list.
        """
        if n == 0:
            return Link(Link.empty) # A list containing the empty partition
        elif n < 0 or m == 0:
            return Link.empty
        else:
            using_m = partitions(n-m, m)
            with_m = map_link(lambda s: Link(m, s), using_m)
            without_m = partitions(n, m-1)
            return with_m + without_m
```

In the recursive case, we construct two sublists of partitions. The first uses `m`, and so we add `m` to each element of the result `using_m` to form `with_m`.

åœ¨é€’å½’çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ„é€ äº†ä¸¤ä¸ªåˆ’åˆ†çš„å­è¡¨ã€‚ç¬¬ä¸€ä¸ªä½¿ç”¨ `m` ï¼Œæ‰€ä»¥æˆ‘ä»¬å°† `m` æ·»åŠ åˆ°ç»“æœ `using_m` çš„æ¯ä¸ªå…ƒç´ ä»¥å½¢æˆ `with_m` ã€‚

The result of `partitions` is highly nested: a linked list of linked lists. Using `join_link` with appropriate separators, we can display the partitions in a human-readable manner.

`partitions` çš„ç»“æœæ˜¯é«˜åº¦åµŒå¥—çš„ï¼šé“¾è¡¨çš„é“¾è¡¨ã€‚ä½¿ç”¨å¸¦æœ‰é€‚å½“åˆ†éš”ç¬¦çš„ `join_link` ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥äººç±»å¯è¯»çš„æ–¹å¼æ˜¾ç¤ºåˆ†åŒºã€‚

```py
>>> def print_partitions(n, m):
        lists = partitions(n, m)
        strings = map_link(lambda s: join_link(s, " + "), lists)
        print(join_link(strings, "\n"))
        
>>> print_partitions(6, 4)
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

## 2.9.2  Tree Class

Trees can also be represented by instances of user-defined classes, rather than nested instances of built-in sequence types. A tree is any data structure that has as an attribute a sequence of branches that are also trees.

æ ‘è¿˜å¯ä»¥ç”±ç”¨æˆ·å®šä¹‰ç±»çš„å®ä¾‹è¡¨ç¤ºï¼Œè€Œä¸æ˜¯ç”±å†…ç½®åºåˆ—ç±»å‹çš„åµŒå¥—å®ä¾‹è¡¨ç¤ºã€‚æ ‘æ˜¯å…·æœ‰ä½œä¸ºå±æ€§çš„ä¹Ÿæ˜¯æ ‘çš„åˆ†æ”¯åºåˆ—çš„ä»»ä½•æ•°æ®ç»“æ„ã€‚

**Internal values.** Previously, we defined trees in such a way that all values appeared at the leaves of the tree. It is also common to define trees that have internal values at the roots of each subtree. An internal value is called an `label` in the tree. The `Tree` class below represents such trees, in which each tree has a sequence of branches that are also trees.

å†…éƒ¨ä»·å€¼è§‚ã€‚ä»¥å‰ï¼Œæˆ‘ä»¬å®šä¹‰æ ‘çš„æ–¹å¼æ˜¯æ‰€æœ‰å€¼éƒ½å‡ºç°åœ¨æ ‘çš„å¶å­ä¸Šã€‚å®šä¹‰åœ¨æ¯ä¸ªå­æ ‘çš„æ ¹å¤„å…·æœ‰å†…éƒ¨å€¼çš„æ ‘ä¹Ÿå¾ˆå¸¸è§ã€‚å†…éƒ¨å€¼åœ¨æ ‘ä¸­ç§°ä¸º `label` ã€‚ä¸‹é¢çš„ `Tree` ç±»è¡¨ç¤ºè¿™æ ·çš„æ ‘ï¼Œå…¶ä¸­æ¯æ£µæ ‘éƒ½æœ‰ä¸€ç³»åˆ—ä¹Ÿæ˜¯æ ‘çš„åˆ†æ”¯ã€‚

```py
>>> class Tree:
        def __init__(self, label, branches=()):
            self.label = label
            for branch in branches:
                assert isinstance(branch, Tree)
            self.branches = branches
        def __repr__(self):
            if self.branches:
                return 'Tree({0}, {1})'.format(self.label, repr(self.branches))
            else:
                return 'Tree({0})'.format(repr(self.label))
        def is_leaf(self):
            return not self.branches
```

The `Tree` class can represent, for instance, the values computed in an expression tree for the recursive implementation of `fib`, the function for computing Fibonacci numbers. The function `fib_tree(n)` below returns a `Tree` that has the nth Fibonacci number as its `label` and a trace of all previously computed Fibonacci numbers within its branches.

`Tree` ç±»å¯ä»¥è¡¨ç¤ºä¾‹å¦‚åœ¨ç”¨äº `fib` çš„é€’å½’å®ç°çš„è¡¨è¾¾å¼æ ‘ä¸­è®¡ç®—çš„å€¼ï¼Œ `fib` æ˜¯ç”¨äºè®¡ç®—Fibonacciæ•°çš„å‡½æ•°ã€‚ä¸‹é¢çš„å‡½æ•° `fib_tree(n)` è¿”å›ä¸€ä¸ª `Tree` ï¼Œå®ƒå°†ç¬¬nä¸ªæ–æ³¢é‚£å¥‘æ•°ä½œä¸º `label` ï¼Œå¹¶è·Ÿè¸ªå…¶åˆ†æ”¯ä¸­æ‰€æœ‰å…ˆå‰è®¡ç®—çš„æ–æ³¢é‚£å¥‘æ•°ã€‚

```py
>>> def fib_tree(n):
        if n == 1:
            return Tree(0)
        elif n == 2:
            return Tree(1)
        else:
            left = fib_tree(n-2)
            right = fib_tree(n-1)
            return Tree(left.label + right.label, (left, right))
>>> fib_tree(5)
Tree(3, (Tree(1, (Tree(0), Tree(1))), Tree(2, (Tree(1), Tree(1, (Tree(0), Tree(1)))))))
```

Trees represented in this way are also processed using recursive functions. For example, we can sum the labels of a tree. As a base case, we return that an empty branch has no labels.

ä»¥è¿™ç§æ–¹å¼è¡¨ç¤ºçš„æ ‘ä¹Ÿä½¿ç”¨é€’å½’å‡½æ•°æ¥å¤„ç†ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ä¸€æ£µæ ‘çš„æ ‡å·æ±‚å’Œã€‚ä½œä¸ºåŸºæœ¬æƒ…å†µï¼Œæˆ‘ä»¬è¿”å›ä¸€ä¸ªç©ºåˆ†æ”¯æ²¡æœ‰æ ‡ç­¾ã€‚

```py
>>> def sum_labels(t):
        """Sum the labels of a Tree instance, which may be None."""
        return t.label + sum([sum_labels(b) for b in t.branches])
    
>>> sum_labels(fib_tree(5))
10
```

We can also apply `memo` to construct a Fibonacci tree, where repeated subtrees are only created once by the memoized version of `fib_tree`, but are used multiple times as branches of different larger trees.

æˆ‘ä»¬ä¹Ÿå¯ä»¥åº”ç”¨ `memo` æ¥æ„é€ æ–æ³¢é‚£å¥‘æ ‘ï¼Œå…¶ä¸­é‡å¤çš„å­æ ‘åªè¢« `fib_tree` çš„è®°å¿†ç‰ˆæœ¬åˆ›å»ºä¸€æ¬¡ï¼Œä½†æ˜¯è¢«å¤šæ¬¡ç”¨ä½œä¸åŒçš„æ›´å¤§çš„æ ‘çš„åˆ†æ”¯ã€‚

```py
>>> fib_tree = memo(fib_tree)
>>> big_fib_tree = fib_tree(35)
>>> big_fib_tree.label
5702887
>>> big_fib_tree.branches[0] is big_fib_tree.branches[1].branches[1]
True
>>> sum_labels = memo(sum_labels)
>>> sum_labels(big_fib_tree)
142587180
```

The amount of computation time and memory saved by memoization in these cases is substantial. Instead of creating 18,454,929 different instances of the `Tree` class, we now create only 35.

åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œè®°å¿†æ³•èŠ‚çœçš„è®¡ç®—æ—¶é—´å’Œå­˜å‚¨é‡æ˜¯ç›¸å½“å¯è§‚çš„ã€‚æˆ‘ä»¬ç°åœ¨åªåˆ›å»º35ä¸ªå®ä¾‹ï¼Œè€Œä¸æ˜¯åˆ›å»º `Tree` ç±»çš„18ï¼Œ454ï¼Œ929ä¸ªä¸åŒå®ä¾‹ã€‚

## 2.9.3 é›†åˆ

é™¤äº†åˆ—è¡¨ï¼ˆlistï¼‰ã€å…ƒç»„ï¼ˆtupleï¼‰å’Œå­—å…¸ï¼ˆdictionaryï¼‰ä¹‹å¤–ï¼ŒPython è¿˜æœ‰ç¬¬å››ç§å†…ç½®çš„å®¹å™¨ç±»å‹ï¼Œå«åš `set` ä¹Ÿå°±æ˜¯é›†åˆã€‚é›†åˆéµå¾ªæ•°å­¦ä¸­çš„è¡¨ç¤ºæ³•ï¼Œå°†å…ƒç´ ä½¿ç”¨èŠ±æ‹¬å·æ‹¬èµ·æ¥ã€‚åœ¨æ„å»ºæ—¶ä¼šåˆ é™¤é‡å¤å…ƒç´ ã€‚é›†åˆæ˜¯æ— åºçš„ï¼Œå› æ­¤æ‰“å°é¡ºåºå¯èƒ½ä¸é›†åˆä¸­å…ƒç´ é¡ºåºä¸åŒã€‚

> è¯‘è€…æ³¨ï¼šå¯¹äºâ€œé›†åˆæ˜¯æ— åºçš„â€è¿™å¥è¯ï¼Œæ›´æ­£ç¡®çš„ç†è§£åº”è¯¥æ˜¯ï¼Œä½¿ç”¨é›†åˆçš„å¼€å‘è€…ä¸åº”è¯¥å‡å®š `set` ä¸­çš„å…ƒç´ å­˜åœ¨é¡ºåºï¼Œå› ä¸º Python å¹¶ä¸ä¿è¯å…¶æœ‰åºæ€§ã€‚

```py
>>> s = {3, 2, 1, 4, 4}
>>> s
{1, 2, 3, 4}
```


Python çš„é›†åˆæ”¯æŒå„ç§è¿ç®—ï¼ŒåŒ…æ‹¬æˆå‘˜æµ‹è¯•ã€é•¿åº¦è®¡ç®—ä»¥åŠæ±‚å¹¶é›†ï¼ˆunionï¼‰å’Œäº¤é›†ï¼ˆintersectionï¼‰çš„æ ‡å‡†é›†åˆè¿ç®—

```py
>>> 3 in s
True
>>> len(s)
4
>>> s.union({1, 5})
{1, 2, 3, 4, 5}
>>> s.intersection({6, 5, 4, 3})
{3, 4}
```

é™¤äº† `union` å’Œ `intersection` ï¼ŒPython é›†åˆè¿˜æ”¯æŒå…¶ä»–å‡ ç§æ–¹æ³•ã€‚`isdisjoint, issubset, issuperset` æä¾›äº†é›†åˆä¹‹é—´çš„æ¯”è¾ƒã€‚é›†åˆæ˜¯å¯å˜çš„ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ `add, remove, discard, pop` ä¸€æ¬¡æ›´æ”¹ä¸€ä¸ªå…ƒç´ ã€‚å…¶å®ƒæ–¹æ³•ï¼Œä¾‹å¦‚ `clear, update` å¯ä»¥ä¸€æ¬¡æ›´æ”¹å¤šä¸ªå…ƒç´ ã€‚åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œ[Python å…³äºé›†åˆçš„æ–‡æ¡£](http://docs.python.org/py3k/library/stdtypes.html#set) åº”è¯¥è¶³å¤Ÿæ¸…æ™°ï¼Œå¯ä»¥å¡«è¡¥æœ¬èŠ‚æ²¡æœ‰æåˆ°çš„æ›´å¤šç»†èŠ‚ã€‚

å®ç°é›†åˆï¼šæŠ½è±¡åœ°è¯´ï¼Œé›†åˆæ˜¯ä¸åŒå¯¹è±¡çš„é›†åˆï¼Œæ”¯æŒæˆå‘˜æµ‹è¯•ã€å¹¶é›†ã€äº¤é›†å’Œæ·»åŠ æ“ä½œã€‚å°†å…ƒç´ ä¸é›†åˆç›¸è¿ä¼šè¿”å›ä¸€ä¸ªæ–°é›†åˆï¼Œè¯¥é›†åˆåŒ…å«åŸå§‹é›†åˆçš„æ‰€æœ‰å…ƒç´ ä»¥åŠæ–°å…ƒç´ ï¼ˆå¦‚æœå®ƒæ˜¯å”¯ä¸€çš„ï¼‰ã€‚å¹¶é›†å’Œäº¤é›†åˆ†åˆ«è¿”å›å‡ºç°åœ¨å…¶ä¸­ä¸€ä¸ªé›†åˆæˆ–ä¸¤ä¸ªé›†åˆä¸­çš„å…ƒç´ é›†ã€‚ä¸ä»»ä½•æ•°æ®æŠ½è±¡ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æä¾›è¯¥è¡Œä¸ºé›†çš„ä»»ä½•é›†åˆè¡¨ç¤ºä¸Šå®ç°ä»»ä½•å‡½æ•°ã€‚

åœ¨æœ¬èŠ‚çš„å‰©ä½™éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†è€ƒè™‘ä¸‰ç§ä¸åŒçš„å®ç°é›†åˆçš„æ–¹æ³•ï¼Œå®ƒä»¬çš„è¡¨ç¤ºå½¢å¼å„ä¸ç›¸åŒã€‚æˆ‘ä»¬å°†é€šè¿‡åˆ†æé›†åˆè¿ç®—çš„å¢é•¿é¡ºåºæ¥è¡¨ç¤ºä¸åŒæ–¹æ³•çš„æ•ˆç‡ã€‚æˆ‘ä»¬å°†ä½¿ç”¨æœ¬èŠ‚å‰é¢æåˆ°çš„ `Link` å’Œ `Tree` ç±»ï¼Œå®ƒä»¬å…è®¸ä½¿ç”¨ç®€å•è€Œä¼˜é›…çš„é€’å½’è§£å†³æ–¹æ¡ˆè§£å†³åŸºæœ¬çš„é›†åˆæ“ä½œã€‚

ä½¿ç”¨æ— åºåºåˆ—è¡¨ç¤ºé›†åˆï¼šè¡¨ç¤ºé›†åˆçš„ä¸€ç§æ–¹æ³•æ˜¯å°†é›†åˆè¡¨ç¤ºä¸ºä¸€ä¸ªå…ƒç´ å”¯ä¸€çš„åºåˆ—ã€‚ç©ºé›†ç”±ç©ºåºåˆ—è¡¨ç¤ºï¼Œé€šè¿‡é€’å½’éå†åˆ—è¡¨æ¥å®ç°æˆå‘˜æµ‹è¯•ã€‚

```py
>>> def empty(s):
        return s is Link.empty
    
>>> def set_contains(s, v):
        """ä»…å½“é›†åˆ s åŒ…å« v æ—¶è¿”å› True"""
        if empty(s):
            return False
        elif s.first == v:
            return True
        else:
            return set_contains(s.rest, v)

>>> s = Link(4, Link(1, Link(5)))
>>> set_contains(s, 2)
False
>>> set_contains(s, 5)
True
```

è¿è¡Œ `set_contains` è¿™ä¸ªæˆå‘˜æµ‹è¯•å‡½æ•°çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯ $\Theta (n)$ ï¼Œå…¶ä¸­ n æ˜¯é›†åˆ `s` çš„å¤§å°ã€‚åˆ©ç”¨è¿™ä¸ªçº¿æ€§æ—¶é—´çš„æˆå‘˜å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨çº¿æ€§æ—¶é—´å†…å°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°é›†åˆä¸­ã€‚

```py
>>> def adjoin_set(s, v):
        """è¿”å›ä¸€ä¸ªåŒ…å« s æ‰€æœ‰å…ƒç´ å’Œå…ƒç´  v çš„é›†åˆ"""
        if set_contains(s, v):
            return s
        else:
            return Link(v, s)

>>> t = adjoin_set(s, 2)
>>> t
Link(2, Link(4, Link(1, Link(5))))
```

In designing a representation, one of the issues with which we should be concerned is efficiency. Intersecting two sets `set1` and `set2` also requires membership testing, but this time each element of `set1` must be tested for membership in `set2`, leading to a quadratic order of growth in the number of steps, Î˜(n2)Î˜(ï¿½2), for two sets of size nï¿½.

åœ¨è®¾è®¡ä¸€ç§è¡¨è¾¾æ–¹å¼æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å…³æ³¨çš„é—®é¢˜ä¹‹ä¸€æ˜¯æ•ˆç‡ã€‚æ±‚ä¸¤ä¸ªé›†åˆ `set1` å’Œ `set2` çš„äº¤é›†ä¹Ÿéœ€è¦æˆå‘˜å…³ç³»æµ‹è¯•ï¼Œä½†è¿™æ¬¡å¿…é¡»æµ‹è¯• `set1` çš„æ¯ä¸ªå…ƒç´ åœ¨ `set2` ä¸­çš„æˆå‘˜å…³ç³»ï¼Œä»è€Œå¯¼è‡´æ­¥æ•°çš„äºŒæ¬¡å¢é•¿ï¼ŒÎ˜ï¼ˆn 2ï¼‰Î˜ï¼ˆğ‘›2ï¼‰ï¼Œå¯¹äºå¤§å°ä¸ºnçš„ä¸¤ä¸ªé›†åˆğ‘›ã€‚

```py
>>> def intersect_set(set1, set2):
        """Return a set containing all elements common to set1 and set2."""
        return keep_if_link(set1, lambda v: set_contains(set2, v))
>>> intersect_set(t, apply_to_all_link(s, square))
Link(4, Link(1))
```

When computing the union of two sets, we must be careful not to include any element twice. The `union_set` function also requires a linear number of membership tests, creating a process that also includes Î˜(n2)Î˜(ï¿½2) steps.

å½“è®¡ç®—ä¸¤ä¸ªé›†åˆçš„å¹¶é›†æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æ³¨æ„ä¸è¦åŒ…å«ä»»ä½•å…ƒç´ ä¸¤æ¬¡ã€‚ `union_set` å‡½æ•°è¿˜éœ€è¦çº¿æ€§æ•°é‡çš„æˆå‘˜å…³ç³»æµ‹è¯•ï¼Œåˆ›å»ºä¸€ä¸ªä¹ŸåŒ…æ‹¬Î˜ï¼ˆn 2ï¼‰Î˜ï¼ˆğ‘›2ï¼‰æ­¥çš„è¿‡ç¨‹ã€‚

```py
>>> def union_set(set1, set2):
        """Return a set containing all elements either in set1 or set2."""
        set1_not_set2 = keep_if_link(set1, lambda v: not set_contains(set2, v))
        return extend_link(set1_not_set2, set2)
>>> union_set(t, s)
Link(2, Link(4, Link(1, Link(5))))
```

**Sets as ordered sequences.** One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. To do this, we need some way to compare two objects so that we can say which is bigger. In Python, many different types of objects can be compared using `<` and `>` operators, but we will concentrate on numbers in this example. We will represent a set of numbers by listing its elements in increasing order.

è®¾ç½®ä¸ºæœ‰åºåºåˆ—ã€‚åŠ é€Ÿé›†åˆè¿ç®—çš„ä¸€ç§æ–¹æ³•æ˜¯æ”¹å˜è¡¨ç¤ºæ³•ï¼Œä½¿é›†åˆå…ƒç´ æŒ‰å‡åºæ’åˆ—ã€‚è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›æ–¹æ³•æ¥æ¯”è¾ƒä¸¤ä¸ªå¯¹è±¡ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥è¯´å“ªä¸ªæ›´å¤§ã€‚åœ¨Pythonä¸­ï¼Œå¯ä»¥ä½¿ç”¨ `<` å’Œ `>` è¿ç®—ç¬¦æ¥æ¯”è¾ƒè®¸å¤šä¸åŒç±»å‹çš„å¯¹è±¡ï¼Œä½†åœ¨æœ¬ä¾‹ä¸­æˆ‘ä»¬å°†é›†ä¸­è®¨è®ºæ•°å­—ã€‚æˆ‘ä»¬å°†é€šè¿‡æŒ‰å‡åºåˆ—å‡ºä¸€ç»„æ•°çš„å…ƒç´ æ¥è¡¨ç¤ºå®ƒã€‚

One advantage of ordering shows up in `set_contains`: In checking for the presence of an object, we no longer have to scan the entire set. If we reach a set element that is larger than the item we are looking for, then we know that the item is not in the set:

è®¢è´­çš„ä¸€ä¸ªä¼˜åŠ¿ä½“ç°åœ¨ `set_contains` ä¸­ï¼šåœ¨æ£€æŸ¥ä¸€ä¸ªç‰©ä½“çš„å­˜åœ¨æ—¶ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦æ‰«ææ•´ä¸ªé›†åˆã€‚å¦‚æœæˆ‘ä»¬åˆ°è¾¾çš„é›†åˆå…ƒç´ å¤§äºæˆ‘ä»¬è¦æŸ¥æ‰¾çš„é¡¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬çŸ¥é“è¯¥é¡¹ä¸åœ¨é›†åˆä¸­ï¼š

```py
>>> def set_contains(s, v):
        if empty(s) or s.first > v:
            return False
        elif s.first == v:
            return True
        else:
            return set_contains(s.rest, v)
>>> u = Link(1, Link(4, Link(5)))
>>> set_contains(u, 0)
False
>>> set_contains(u, 4)
True
```

How many steps does this save? In the worst case, the item we are looking for may be the largest one in the set, so the number of steps is the same as for the unordered representation. On the other hand, if we search for items of many different sizes we can expect that sometimes we will be able to stop searching at a point near the beginning of the list and that other times we will still need to examine most of the list. On average we should expect to have to examine about half of the items in the set. Thus, the average number of steps required will be about n2ï¿½2. This is still Î˜(n)Î˜(ï¿½) growth, but it does save us some time in practice over the previous implementation.

è¿™æ ·å¯ä»¥ä¿å­˜å¤šå°‘æ­¥éª¤ï¼Ÿåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„é¡¹å¯èƒ½æ˜¯é›†åˆä¸­æœ€å¤§çš„ä¸€ä¸ªï¼Œå› æ­¤æ­¥éª¤æ•°ä¸æ— åºè¡¨ç¤ºç›¸åŒã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæˆ‘ä»¬æœç´¢è®¸å¤šä¸åŒå¤§å°çš„é¡¹ç›®ï¼Œæˆ‘ä»¬å¯ä»¥é¢„æœŸï¼Œæœ‰æ—¶æˆ‘ä»¬å°†èƒ½å¤Ÿåœ¨åˆ—è¡¨å¼€å§‹é™„è¿‘çš„ç‚¹åœæ­¢æœç´¢ï¼Œè€Œå…¶ä»–æ—¶å€™æˆ‘ä»¬ä»ç„¶éœ€è¦æ£€æŸ¥åˆ—è¡¨çš„å¤§éƒ¨åˆ†ã€‚å¹³å‡æ¥è¯´ï¼Œæˆ‘ä»¬åº”è¯¥é¢„æœŸå¿…é¡»æ£€æŸ¥é›†åˆä¸­å¤§çº¦ä¸€åŠçš„é¡¹ç›®ã€‚å› æ­¤ï¼Œæ‰€éœ€çš„å¹³å‡æ­¥éª¤æ•°çº¦ä¸ºğ‘›n22ã€‚è¿™ä»ç„¶æ˜¯Î˜ï¼ˆnï¼‰Î˜ï¼ˆğ‘›ï¼‰çš„å¢é•¿ï¼Œä½†åœ¨å®è·µä¸­æ¯”å‰é¢çš„å®ç°ä¿å­˜äº†ä¸€äº›æ—¶é—´ã€‚

We can obtain a more impressive speedup by re-implementing `intersect_set`. In the unordered representation, this operation required Î˜(n2)Î˜(ï¿½2) steps because we performed a complete scan of `set2` for each element of `set1`. But with the ordered representation, we can use a more clever method. We iterate through both sets simultaneously, tracking an element `e1` in `set1` and `e2` in `set2`. When `e1` and `e2` are equal, we include that element in the intersection.

æˆ‘ä»¬å¯ä»¥é€šè¿‡é‡æ–°å®ç° `intersect_set` æ¥è·å¾—æ›´æ˜¾è‘—çš„åŠ é€Ÿã€‚åœ¨æ— åºè¡¨ç¤ºä¸­ï¼Œè¿™ä¸ªæ“ä½œéœ€è¦Î˜ï¼ˆn 2ï¼‰Î˜ï¼ˆğ‘›2ï¼‰æ­¥ï¼Œå› ä¸ºæˆ‘ä»¬å¯¹ `set2` çš„æ¯ä¸ªå…ƒç´ éƒ½è¿›è¡Œäº†å®Œæ•´çš„æ‰«æã€‚ä½†æ˜¯å¯¹äºæœ‰åºè¡¨ç¤ºï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´èªæ˜çš„æ–¹æ³•ã€‚æˆ‘ä»¬åŒæ—¶è¿­ä»£ä¸¤ä¸ªé›†åˆï¼Œåœ¨ `set1` ä¸­è·Ÿè¸ªå…ƒç´  `e1` ï¼Œåœ¨ `set2` ä¸­è·Ÿè¸ªå…ƒç´  `e2` ã€‚å½“ `e1` å’Œ `e2` ç›¸ç­‰æ—¶ï¼Œæˆ‘ä»¬å°†è¯¥å…ƒç´ åŒ…å«åœ¨äº¤é›†ä¸­ã€‚

Suppose, however, that `e1` is less than `e2`. Since `e2` is smaller than the remaining elements of `set2`, we can immediately conclude that `e1` cannot appear anywhere in the remainder of `set2` and hence is not in the intersection. Thus, we no longer need to consider `e1`; we discard it and proceed to the next element of `set1`. Similar logic advances through the elements of `set2` when `e2 < e1`. Here is the function:

ç„¶è€Œï¼Œå‡è®¾ `e1` å°äº `e2` ã€‚ç”±äº `e2` å°äº `set2` çš„å…¶ä½™å…ƒç´ ï¼Œæˆ‘ä»¬å¯ä»¥ç«‹å³å¾—å‡ºç»“è®ºï¼Œ `e1` ä¸å¯èƒ½å‡ºç°åœ¨ `set2` çš„å…¶ä½™å…ƒç´ ä¸­çš„ä»»ä½•åœ°æ–¹ï¼Œå› æ­¤ä¸åœ¨äº¤é›†ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦è€ƒè™‘ `e1` ;æˆ‘ä»¬ä¸¢å¼ƒå®ƒå¹¶ç»§ç»­ `set1` çš„ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚å½“ `e2 < e1` æ—¶ï¼Œç±»ä¼¼çš„é€»è¾‘é€šè¿‡ `set2` çš„å…ƒç´ å‰è¿›ã€‚å‡½æ•°å¦‚ä¸‹ï¼š

```py
>>> def intersect_set(set1, set2):
        if empty(set1) or empty(set2):
            return Link.empty
        else:
            e1, e2 = set1.first, set2.first
            if e1 == e2:
                return Link(e1, intersect_set(set1.rest, set2.rest))
            elif e1 < e2:
                return intersect_set(set1.rest, set2)
            elif e2 < e1:
                return intersect_set(set1, set2.rest)
            
>>> intersect_set(s, s.rest)
Link(4, Link(5))
```

To estimate the number of steps required by this process, observe that in each step we shrink the size of at least one of the sets. Thus, the number of steps required is at most the sum of the sizes of `set1` and `set2`, rather than the product of the sizes, as with the unordered representation. This is Î˜(n)Î˜(ï¿½) growth rather than Î˜(n2)Î˜(ï¿½2) -- a considerable speedup, even for sets of moderate size. For example, the intersection of two sets of size 100 will take around 200 steps, rather than 10,000 for the unordered representation.

ä¸ºäº†ä¼°è®¡è¿™ä¸ªè¿‡ç¨‹æ‰€éœ€çš„æ­¥éª¤æ•°ï¼Œè§‚å¯Ÿåˆ°åœ¨æ¯ä¸€æ­¥ä¸­æˆ‘ä»¬è‡³å°‘ç¼©å°äº†ä¸€ä¸ªé›†åˆçš„å¤§å°ã€‚å› æ­¤ï¼Œæ‰€éœ€çš„æ­¥éª¤æ•°è‡³å¤šæ˜¯ `set1` å’Œ `set2` çš„å¤§å°ä¹‹å’Œï¼Œè€Œä¸æ˜¯å¦‚æ— åºè¡¨ç¤ºé‚£æ ·æ˜¯å¤§å°çš„ä¹˜ç§¯ã€‚è¿™æ˜¯Î˜ï¼ˆnï¼‰Î˜ï¼ˆğ‘›ï¼‰çš„å¢é•¿ï¼Œè€Œä¸æ˜¯Î˜ï¼ˆn2ï¼‰Î˜ï¼ˆğ‘›2ï¼‰--è¿™æ˜¯ä¸€ä¸ªç›¸å½“å¤§çš„åŠ é€Ÿï¼Œå³ä½¿å¯¹äºä¸­ç­‰å¤§å°çš„é›†åˆã€‚ä¾‹å¦‚ï¼Œå¤§å°ä¸º100çš„ä¸¤ä¸ªé›†åˆçš„äº¤é›†å°†èŠ±è´¹å¤§çº¦200æ­¥ï¼Œè€Œä¸æ˜¯æ— åºè¡¨ç¤ºçš„10ï¼Œ000æ­¥ã€‚

Adjunction and union for sets represented as ordered sequences can also be computed in linear time. These implementations are left as an exercise.

è¡¨ç¤ºä¸ºæœ‰åºåºåˆ—çš„é›†åˆçš„å¹¶å’Œä¹Ÿå¯ä»¥åœ¨çº¿æ€§æ—¶é—´å†…è®¡ç®—ã€‚è¿™äº›å®ç°ä½œä¸ºç»ƒä¹ ç•™ä¸‹ã€‚

**Sets as binary search trees.** We can do better than the ordered-list representation by arranging the set elements in the form of a tree with exactly two branches. The `entry` of the root of the tree holds one element of the set. The entries within the `left` branch include all elements smaller than the one at the root. Entries in the `right` branch include all elements greater than the one at the root. The figure below shows some trees that represent the set `{1, 3, 5, 7, 9, 11}`. The same set may be represented by a tree in a number of different ways. In all binary search trees, all elements in the `left` branch be smaller than the `entry` at the root, and that all elements in the `right` subtree be larger.

è®¾ç½®ä¸ºäºŒå‰æœç´¢æ ‘ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†é›†åˆå…ƒç´ æ’åˆ—æˆä¸€ä¸ªæ°å¥½æœ‰ä¸¤ä¸ªåˆ†æ”¯çš„æ ‘çš„å½¢å¼æ¥åšå¾—æ¯”æœ‰åºåˆ—è¡¨è¡¨ç¤ºæ›´å¥½ã€‚æ ‘çš„æ ¹çš„ `entry` æŒæœ‰é›†åˆçš„ä¸€ä¸ªå…ƒç´ ã€‚ `left` åˆ†æ”¯å†…çš„æ¡ç›®åŒ…æ‹¬å°äºæ ¹å¤„çš„æ¡ç›®çš„æ‰€æœ‰å…ƒç´ ã€‚ `right` åˆ†æ”¯ä¸­çš„æ¡ç›®åŒ…æ‹¬å¤§äºæ ¹å¤„çš„å…ƒç´ çš„æ‰€æœ‰å…ƒç´ ã€‚ä¸‹å›¾æ˜¾ç¤ºäº†ä»£è¡¨é›†åˆ `{1, 3, 5, 7, 9, 11}` çš„ä¸€äº›æ ‘ã€‚åŒä¸€ä¸ªé›†åˆå¯ä»¥ç”¨æ ‘ä»¥è®¸å¤šä¸åŒçš„æ–¹å¼æ¥è¡¨ç¤ºã€‚åœ¨æ‰€æœ‰äºŒå‰æœç´¢æ ‘ä¸­ï¼Œ `left` åˆ†æ”¯ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å°äºæ ¹å¤„çš„ `entry` ï¼Œå¹¶ä¸” `right` å­æ ‘ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½å¤§äºæ ¹å¤„çš„ `entry` ã€‚

![set_trees](/sicp-python/set_trees.png)

The advantage of the tree representation is this: Suppose we want to check whether a value `v` is contained in a set. We begin by comparing `v` with `entry`. If `v` is less than this, we know that we need only search the `left` subtree; if `v` is greater, we need only search the `right` subtree. Now, if the tree is "balanced," each of these subtrees will be about half the size of the original. Thus, in one step we have reduced the problem of searching a tree of size nï¿½ to searching a tree of size n2ï¿½2. Since the size of the tree is halved at each step, we should expect that the number of steps needed to search a tree grows as Î˜(logn)Î˜(logâ¡ï¿½). For large sets, this will be a significant speedup over the previous representations. This `set_contains` function exploits the ordering structure of the tree-structured set.

æ ‘è¡¨ç¤ºæ³•çš„ä¼˜ç‚¹æ˜¯ï¼šå‡è®¾æˆ‘ä»¬æƒ³è¦æ£€æŸ¥å€¼ `v` æ˜¯å¦åŒ…å«åœ¨é›†åˆä¸­ã€‚æˆ‘ä»¬å¼€å§‹æ¯”è¾ƒ `v` å’Œ `entry` ã€‚å¦‚æœ `v` å°äºè¿™ä¸ªå€¼ï¼Œæˆ‘ä»¬çŸ¥é“æˆ‘ä»¬åªéœ€è¦æœç´¢ `left` å­æ ‘;å¦‚æœ `v` æ›´å¤§ï¼Œæˆ‘ä»¬åªéœ€è¦æœç´¢ `right` å­æ ‘ã€‚ç°åœ¨ï¼Œå¦‚æœæ ‘æ˜¯â€œå¹³è¡¡çš„â€ï¼Œé‚£ä¹ˆæ¯ä¸ªå­æ ‘çš„å¤§å°å°†æ˜¯åŸå§‹æ ‘çš„ä¸€åŠã€‚å› æ­¤ï¼Œåœ¨ä¸€ä¸ªæ­¥éª¤ä¸­ï¼Œæˆ‘ä»¬å·²ç»å°†æœç´¢å¤§å°ä¸ºnçš„æ ‘çš„é—®é¢˜ç®€åŒ–ğ‘›ä¸ºæœç´¢å¤§å°ä¸ºn22çš„æ ‘ğ‘›ã€‚ç”±äºæ ‘çš„å¤§å°åœ¨æ¯ä¸€æ­¥éƒ½å‡åŠï¼Œæˆ‘ä»¬å¯ä»¥é¢„æœŸæœç´¢æ ‘æ‰€éœ€çš„æ­¥æ•°ä»¥Î˜ï¼ˆlognï¼‰Î˜ï¼ˆlogï¼‰çš„é€Ÿåº¦å¢é•¿ğ‘›ã€‚å¯¹äºå¤§å‹é›†åˆï¼Œè¿™å°†æ˜¯ä¸€ä¸ªæ˜¾ç€çš„åŠ é€Ÿæ¯”ä»¥å‰çš„è¡¨ç¤ºã€‚è¿™ä¸ª `set_contains` å‡½æ•°åˆ©ç”¨äº†æ ‘å½¢ç»“æ„é›†åˆçš„æ’åºç»“æ„ã€‚

```py
>>> def set_contains(s, v):
        if s is None:
            return False
        elif s.entry == v:
            return True
        elif s.entry < v:
            return set_contains(s.right, v)
        elif s.entry > v:
            return set_contains(s.left, v)
```

Adjoining an item to a set is implemented similarly and also requires Î˜(logn)Î˜(logâ¡ï¿½) steps. To adjoin a value `v`, we compare `v` with `entry` to determine whether `v` should be added to the `right` or to the `left` branch, and having adjoined `v` to the appropriate branch we piece this newly constructed branch together with the original `entry` and the other branch. If `v` is equal to the `entry`, we just return the node. If we are asked to adjoin `v` to an empty tree, we generate a `Tree` that has `v` as the `entry` and empty `right` and `left` branches. Here is the function:

å°†ä¸€ä¸ªé¡¹æ·»åŠ åˆ°ä¸€ä¸ªé›†åˆçš„å®ç°æ–¹å¼ç±»ä¼¼ï¼Œä¹Ÿéœ€è¦Î˜ï¼ˆlognï¼‰Î˜ï¼ˆlogğ‘›ï¼‰æ­¥ã€‚ä¸ºäº†é‚»æ¥å€¼ `v` ï¼Œæˆ‘ä»¬æ¯”è¾ƒ `v` å’Œ `entry` ä»¥ç¡®å®š `v` æ˜¯å¦åº”è¯¥è¢«æ·»åŠ åˆ° `right` æˆ– `left` åˆ†æ”¯ï¼Œå¹¶ä¸”åœ¨å°† `v` é‚»æ¥åˆ°é€‚å½“çš„åˆ†æ”¯ä¹‹åï¼Œæˆ‘ä»¬å°†è¿™ä¸ªæ–°æ„é€ çš„åˆ†æ”¯ä¸åŸå§‹çš„ `entry` å’Œå¦ä¸€ä¸ªåˆ†æ”¯æ‹¼æ¥åœ¨ä¸€èµ·ã€‚å¦‚æœ `v` ç­‰äº `entry` ï¼Œæˆ‘ä»¬å°±è¿”å›èŠ‚ç‚¹ã€‚å¦‚æœæˆ‘ä»¬è¢«è¦æ±‚æŠŠ `v` è¿æ¥åˆ°ä¸€ä¸ªç©ºæ ‘ï¼Œæˆ‘ä»¬ç”Ÿæˆä¸€ä¸ª `Tree` ï¼Œå®ƒæœ‰ `v` ä½œä¸º `entry` ï¼Œä»¥åŠç©ºçš„ `right` å’Œ `left` åˆ†æ”¯ã€‚å‡½æ•°å¦‚ä¸‹ï¼š

```py
>>> def adjoin_set(s, v):
        if s is None:
            return Tree(v)
        elif s.entry == v:
            return s
        elif s.entry < v:
            return Tree(s.entry, s.left, adjoin_set(s.right, v))
        elif s.entry > v:
            return Tree(s.entry, adjoin_set(s.left, v), s.right)
>>> adjoin_set(adjoin_set(adjoin_set(None, 2), 3), 1)
Tree(2, Tree(1), Tree(3))
```

Our claim that searching the tree can be performed in a logarithmic number of steps rests on the assumption that the tree is "balanced," i.e., that the left and the right subtree of every tree have approximately the same number of elements, so that each subtree contains about half the elements of its parent. But how can we be certain that the trees we construct will be balanced? Even if we start with a balanced tree, adding elements with `adjoin_set` may produce an unbalanced result. Since the position of a newly adjoined element depends on how the element compares with the items already in the set, we can expect that if we add elements "randomly" the tree will tend to be balanced on the average.

æˆ‘ä»¬å…³äºæœç´¢æ ‘å¯ä»¥ä»¥å¯¹æ•°ä¸ªæ­¥éª¤æ¥æ‰§è¡Œçš„ä¸»å¼ åŸºäºè¿™æ ·çš„å‡è®¾ï¼šæ ‘æ˜¯â€œå¹³è¡¡çš„â€ï¼Œå³ï¼Œæ¯ä¸ªæ ‘çš„å·¦å’Œå³å­æ ‘å…·æœ‰è¿‘ä¼¼ç›¸åŒæ•°é‡çš„å…ƒç´ ï¼Œä½¿å¾—æ¯ä¸ªå­æ ‘åŒ…å«å…¶çˆ¶æ ‘çš„å¤§çº¦ä¸€åŠçš„å…ƒç´ ã€‚ä½†æ˜¯æˆ‘ä»¬å¦‚ä½•ç¡®å®šæˆ‘ä»¬æ„å»ºçš„æ ‘æ˜¯å¹³è¡¡çš„å‘¢ï¼Ÿå³ä½¿æˆ‘ä»¬ä»å¹³è¡¡æ ‘å¼€å§‹ï¼Œæ·»åŠ å¸¦æœ‰ `adjoin_set` çš„å…ƒç´ ä¹Ÿå¯èƒ½äº§ç”Ÿä¸å¹³è¡¡çš„ç»“æœã€‚ç”±äºæ–°é‚»æ¥å…ƒç´ çš„ä½ç½®å–å†³äºè¯¥å…ƒç´ ä¸é›†åˆä¸­å·²æœ‰å…ƒç´ çš„æ¯”è¾ƒç»“æœï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é¢„æœŸï¼Œå¦‚æœâ€œéšæœºâ€æ·»åŠ å…ƒç´ ï¼Œåˆ™æ ‘å°†è¶‹äºå¹³å‡å¹³è¡¡ã€‚

But this is not a guarantee. For example, if we start with an empty set and adjoin the numbers 1 through 7 in sequence we end up with a highly unbalanced tree in which all the left subtrees are empty, so it has no advantage over a simple ordered list. One way to solve this problem is to define an operation that transforms an arbitrary tree into a balanced tree with the same elements. We can perform this transformation after every few `adjoin_set` operations to keep our set in balance.

ä½†è¿™å¹¶ä¸æ˜¯ä¿è¯ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ä»ä¸€ä¸ªç©ºé›†å¼€å§‹ï¼Œå¹¶æŒ‰é¡ºåºé‚»æ¥æ•°å­—1åˆ°7ï¼Œæˆ‘ä»¬æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªé«˜åº¦ä¸å¹³è¡¡çš„æ ‘ï¼Œå…¶ä¸­æ‰€æœ‰å·¦è¾¹çš„å­æ ‘éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰ç®€å•æœ‰åºåˆ—è¡¨çš„ä¼˜åŠ¿ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªæ–¹æ³•æ˜¯å®šä¹‰ä¸€ä¸ªæ“ä½œï¼Œå°†ä»»æ„æ ‘è½¬æ¢ä¸ºå…·æœ‰ç›¸åŒå…ƒç´ çš„å¹³è¡¡æ ‘ã€‚æˆ‘ä»¬å¯ä»¥åœ¨æ¯éš”å‡ ä¸ª `adjoin_set` æ“ä½œä¹‹åæ‰§è¡Œè¿™ä¸ªè½¬æ¢ï¼Œä»¥ä¿æŒé›†åˆçš„å¹³è¡¡ã€‚

Intersection and union operations can be performed on tree-structured sets in linear time by converting them to ordered lists and back. The details are left as an exercise.

äº¤é›†å’Œå¹¶é›†è¿ç®—å¯ä»¥åœ¨çº¿æ€§æ—¶é—´å†…å¯¹æ ‘ç»“æ„é›†åˆæ‰§è¡Œï¼Œæ–¹æ³•æ˜¯å°†å®ƒä»¬è½¬æ¢æˆæœ‰åºåˆ—è¡¨å¹¶åè¿‡æ¥ã€‚ç»†èŠ‚ç•™å¾…ç»ƒä¹ ã€‚

**Python set implementation.** The `set` type that is built into Python does not use any of these representations internally. Instead, Python uses a representation that gives constant-time membership tests and adjoin operations based on a technique called *hashing*, which is a topic for another course. Built-in Python sets cannot contain mutable data types, such as lists, dictionaries, or other sets. To allow for nested sets, Python also includes a built-in immutable `frozenset` class that shares methods with the `set` class but excludes mutation methods and operators.

Pythoné›†åˆå®ç°ã€‚Pythonä¸­å†…ç½®çš„ `set` ç±»å‹åœ¨å†…éƒ¨ä¸ä½¿ç”¨è¿™äº›è¡¨ç¤ºã€‚ç›¸åï¼ŒPythonä½¿ç”¨äº†ä¸€ç§è¡¨ç¤ºæ³•ï¼Œå®ƒåŸºäºä¸€ç§å«åšæ•£åˆ—çš„æŠ€æœ¯ï¼Œç»™å‡ºäº†æ’å®šæ—¶é—´çš„æˆå‘˜æµ‹è¯•å’Œé‚»æ¥æ“ä½œï¼Œè¿™æ˜¯å¦ä¸€é—¨è¯¾ç¨‹çš„ä¸»é¢˜ã€‚å†…ç½®Pythoné›†åˆä¸èƒ½åŒ…å«å¯å˜æ•°æ®ç±»å‹ï¼Œå¦‚åˆ—è¡¨ã€å­—å…¸æˆ–å…¶ä»–é›†åˆã€‚ä¸ºäº†å…è®¸åµŒå¥—é›†åˆï¼ŒPythonè¿˜åŒ…å«äº†ä¸€ä¸ªå†…ç½®çš„ä¸å¯å˜çš„ `frozenset` ç±»ï¼Œå®ƒä¸ `set` ç±»å…±äº«æ–¹æ³•ï¼Œä½†æ’é™¤äº†å˜å¼‚æ–¹æ³•å’Œæ“ä½œç¬¦ã€‚