# 2.5 面向对象编程

:::info
译者：[Mancuoj](https://github.com/mancuoj)

来源：[2.5 Object-Oriented Programming](http://composingprograms.com/pages/25-object-oriented-programming.html)

对应：Disc 05、HW 04、Lab 06、Ants

:::




Object-oriented programming (OOP) is a method for organizing programs that brings together many of the ideas introduced in this chapter. Like the functions in data abstraction, classes create abstraction barriers between the use and implementation of data. Like dispatch dictionaries, objects respond to behavioral requests. Like mutable data structures, objects have local state that is not directly accessible from the global environment. The Python object system provides convenient syntax to promote the use of these techniques for organizing programs. Much of this syntax is shared among other object-oriented programming languages.
面向对象编程（OOP）是一种组织程序的方法，它将本章介绍的许多思想结合在一起。就像数据抽象中的函数一样，类在数据的使用和实现之间创建抽象屏障。像分派字典一样，对象响应行为请求。像可变数据结构一样，对象具有不能从全局环境直接访问的局部状态。Python对象系统提供了方便的语法来促进这些技术在组织程序中的使用。许多这种语法在其他面向对象的编程语言中是共享的。

The object system offers more than just convenience. It enables a new metaphor for designing programs in which several independent agents interact within the computer. Each object bundles together local state and behavior in a way that abstracts the complexity of both. Objects communicate with each other, and useful results are computed as a consequence of their interaction. Not only do objects pass messages, they also share behavior among other objects of the same type and inherit characteristics from related types.
对象系统提供的不仅仅是方便。它为设计程序提供了一个新的比喻，在程序中，几个独立的代理在计算机中交互。每个对象以一种抽象了本地状态和行为的复杂性的方式将二者捆绑在一起。对象之间相互通信，并且有用的结果作为它们交互的结果被计算出来。对象不仅传递消息，它们还在相同类型的其他对象之间共享行为，并从相关类型继承特征。

The paradigm of object-oriented programming has its own vocabulary that supports the object metaphor. We have seen that an object is a data value that has methods and attributes, accessible via dot notation. Every object also has a type, called its *class*. To create new types of data, we implement new classes.
面向对象编程的范例有自己的词汇表，支持对象隐喻。我们已经看到，对象是一个具有方法和属性的数据值，可以通过点符号访问。每个对象还有一个类型，称为它的类。为了创建新的数据类型，我们实现了新的类。

## 2.5.1  Objects and Classes 2.5.1 对象和类

A class serves as a template for all objects whose type is that class. Every object is an instance of some particular class. The objects we have used so far all have built-in classes, but new user-defined classes can be created as well. A class definition specifies the attributes and methods shared among objects of that class. We will introduce the class statement by revisiting the example of a bank account.
一个类充当所有其类型为该类的对象的模板。每个对象都是某个特定类的实例。到目前为止，我们使用的对象都有内置类，但也可以创建新的用户定义类。类定义指定该类的对象之间共享的属性和方法。我们将通过重新访问银行帐户的示例来介绍class语句。

When introducing local state, we saw that bank accounts are naturally modeled as mutable values that have a `balance`. A bank account object should have a `withdraw` method that updates the account balance and returns the requested amount, if it is available. To complete the abstraction: a bank account should be able to return its current `balance`, return the name of the account `holder`, and an amount for `deposit`.
在引入本地状态时，我们看到银行账户自然地被建模为具有 `balance` 的可变值。银行帐户对象应该有 `withdraw` 方法，用于更新帐户余额并返回请求的金额（如果可用）。要完成抽象：银行账户应该能够返回其当前 `balance` 、返回账户 `holder` 的名称以及 `deposit` 的金额。

An `Account` class allows us to create multiple instances of bank accounts. The act of creating a new object instance is known as *instantiating* the class. The syntax in Python for instantiating a class is identical to the syntax of calling a function. In this case, we call `Account` with the argument `'Kirk'`, the account holder's name.
`Account` 类允许我们创建多个银行账户实例。创建新对象实例的操作称为实例化类。Python中实例化类的语法与调用函数的语法相同。在本例中，我们使用参数 `'Kirk'` （帐户保持器的姓名）调用 `Account` 。

```
>>> a = Account('Kirk')
```

An *attribute* of an object is a name-value pair associated with the object, which is accessible via dot notation. The attributes specific to a particular object, as opposed to all objects of a class, are called *instance attributes*. Each `Account` has its own balance and account holder name, which are examples of instance attributes. In the broader programming community, instance attributes may also be called *fields*, *properties*, or *instance variables*.
对象的属性是与对象相关联的名称-值对，可通过点符号访问。与类的所有对象相对，特定于特定对象的属性称为实例属性。每个 `Account` 都有自己的余额和帐户保持器名称，这是实例属性的示例。在更广泛的编程社区中，实例属性也可以称为字段、属性或实例变量。

```
>>> a.holder
'Kirk'
>>> a.balance
0
```

Functions that operate on the object or perform object-specific computations are called methods. The return values and side effects of a method can depend upon and change other attributes of the object. For example, `deposit` is a method of our `Account` object `a`. It takes one argument, the amount to deposit, changes the `balance` attribute of the object, and returns the resulting balance.
对对象进行操作或执行特定于对象的计算的函数称为方法。方法的返回值和副作用可以依赖于并更改对象的其他属性。例如， `deposit` 是 `Account` 对象 `a` 的一个方法。它接受一个参数（存款金额），更改对象的 `balance` 属性，并返回结果余额。

```
>>> a.deposit(15)
15
```

We say that methods are *invoked* on a particular object. As a result of invoking the `withdraw` method, either the withdrawal is approved and the amount is deducted, or the request is declined and the method returns an error message.
我们说方法是在一个特定的对象上调用的。调用 `withdraw` 方法的结果是，要么批准提款并扣除金额，要么拒绝请求并返回错误消息。

```
>>> a.withdraw(10)  # The withdraw method returns the balance after withdrawal
5
>>> a.balance       # The balance attribute has changed
5
>>> a.withdraw(10)
'Insufficient funds'
```

As illustrated above, the behavior of a method can depend upon the changing attributes of the object. Two calls to `withdraw` with the same argument return different results.
如上所述，方法的行为可取决于对象的变化属性。使用同一参数两次调用 `withdraw` 返回不同的结果。

## 2.5.2  Defining Classes 2.5.2 定义类

User-defined classes are created by `class` statements, which consist of a single clause. A class statement defines the class name, then includes a suite of statements to define the attributes of the class:
用户定义类由 `class` 语句创建，这些语句由单个子句组成。class语句定义类名，然后包含一组语句来定义类的属性：

```
class <name>:
    <suite>
```

When a class statement is executed, a new class is created and bound to `<name>` in the first frame of the current environment. The suite is then executed. Any names bound within the `<suite>` of a `class` statement, through `def` or assignment statements, create or modify attributes of the class.
当执行class语句时，将创建一个新类，并将其绑定到当前环境的第一帧中的 `<name>` 。然后执行该套件。通过 `def` 或赋值语句，在 `class` 语句的 `<suite>` 内绑定的任何名称都可以创建或修改类的属性。

Classes are typically organized around manipulating instance attributes, which are the name-value pairs associated with each instance of that class. The class specifies the instance attributes of its objects by defining a method for initializing new objects. For example, part of initializing an object of the `Account` class is to assign it a starting balance of 0.
类通常围绕操作实例属性来组织，实例属性是与该类的每个实例相关联的名称-值对。类通过定义初始化新对象的方法来指定其对象的实例属性。例如，初始化 `Account` 类的对象的一部分是为其分配起始余额0。

The `<suite>` of a `class` statement contains `def` statements that define new methods for objects of that class. The method that initializes objects has a special name in Python, `__init__` (two underscores on each side of the word "init"), and is called the *constructor* for the class.
`class` 语句的 `<suite>` 包含为该类的对象定义新方法的 `def` 语句。初始化对象的方法在Python中有一个特殊的名字， `__init__` （单词“init”两边有两个下划线），它被称为类的构造函数。

```
>>> class Account:
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
```

The `__init__` method for `Account` has two formal parameters. The first one, `self`, is bound to the newly created `Account` object. The second parameter, `account_holder`, is bound to the argument passed to the class when it is called to be instantiated.
`Account` 的 `__init__` 方法有两个形参。第一个对象 `self` 绑定到新创建的 `Account` 对象。第二个参数 `account_holder` 绑定到调用该类进行实例化时传递给该类的参数。

The constructor binds the instance attribute name `balance` to 0. It also binds the attribute name `holder` to the value of the name `account_holder`. The formal parameter `account_holder` is a local name in the `__init__` method. On the other hand, the name `holder` that is bound via the final assignment statement persists, because it is stored as an attribute of `self` using dot notation.
构造函数将实例属性名 `balance` 绑定到0。它还将属性名称 `holder` 绑定到名称 `account_holder` 的值。形参 `account_holder` 是 `__init__` 方法中的局部名称。另一方面，通过最后的赋值语句绑定的名称 `holder` 持续存在，因为它使用点符号存储为 `self` 的属性。

Having defined the `Account` class, we can instantiate it.
定义了 `Account` 类之后，我们可以实例化它。

```
>>> a = Account('Kirk')
```

This "call" to the `Account` class creates a new object that is an instance of `Account`, then calls the constructor function `__init__` with two arguments: the newly created object and the string `'Kirk'`. By convention, we use the parameter name `self` for the first argument of a constructor, because it is bound to the object being instantiated. This convention is adopted in virtually all Python code.
这个对 `Account` 类的“调用”创建了一个作为 `Account` 的实例的新对象，然后用两个参数调用构造函数 `__init__` ：新建对象和字符串 `'Kirk'` 。按照惯例，我们使用参数名 `self` 作为构造函数的第一个参数，因为它绑定到正在实例化的对象。几乎所有的Python代码都采用这种约定。

Now, we can access the object's `balance` and `holder` using dot notation.
现在，我们可以使用点标记法访问对象的 `balance` 和 `holder` 。

```
>>> a.balance
0
>>> a.holder
'Kirk'
```

**Identity.** Each new account instance has its own balance attribute, the value of which is independent of other objects of the same class.
身份。每个新帐户实例都有自己的balance属性，该属性的值独立于同一类的其他对象。

```
>>> b = Account('Spock')
>>> b.balance = 200
>>> [acc.balance for acc in (a, b)]
[0, 200]
```

To enforce this separation, every object that is an instance of a user-defined class has a unique identity. Object identity is compared using the `is` and `is not` operators.
为了强制这种分离，作为用户定义类实例的每个对象都具有唯一标识。使用 `is` 和 `is not` 运算符比较对象标识。

```
>>> a is a
True
>>> a is not b
True
```

Despite being constructed from identical calls, the objects bound to `a` and `b` are not the same. As usual, binding an object to a new name using assignment does not create a new object.
尽管是从相同的调用构造的，但绑定到 `a` 和 `b` 的对象并不相同。通常，使用赋值将对象绑定到新名称不会创建新对象。

```
>>> c = a
>>> c is a
True
```

New objects that have user-defined classes are only created when a class (such as `Account`) is instantiated with call expression syntax.
只有在使用调用表达式语法实例化类（如 `Account` ）时，才会创建具有用户定义类的新对象。

**Methods.** Object methods are also defined by a `def` statement in the suite of a `class` statement. Below, `deposit` and `withdraw` are both defined as methods on objects of the `Account` class.
方法。对象方法也由 `class` 语句组中的 `def` 语句定义。下面， `deposit` 和 `withdraw` 都被定义为 `Account` 类的对象上的方法。

```
>>> class Account:
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
        def deposit(self, amount):
            self.balance = self.balance + amount
            return self.balance
        def withdraw(self, amount):
            if amount > self.balance:
                return 'Insufficient funds'
            self.balance = self.balance - amount
            return self.balance
```

While method definitions do not differ from function definitions in how they are declared, method definitions do have a different effect when executed. The function value that is created by a `def` statement within a `class` statement is bound to the declared name, but bound locally within the class as an attribute. That value is invoked as a method using dot notation from an instance of the class.
虽然方法定义与函数定义在声明方式上没有区别，但方法定义在执行时确实会产生不同的效果。由 `class` 语句中的 `def` 语句创建的函数值绑定到声明的名称，但作为属性在类中本地绑定。从类的实例中使用点标记法将该值作为方法调用。

Each method definition again includes a special first parameter `self`, which is bound to the object on which the method is invoked. For example, let us say that `deposit` is invoked on a particular `Account` object and passed a single argument value: the amount deposited. The object itself is bound to `self`, while the argument is bound to `amount`. All invoked methods have access to the object via the `self` parameter, and so they can all access and manipulate the object's state.
每个方法定义又包括一个特殊的第一个参数 `self` ，它绑定到调用该方法的对象。例如，假设 `deposit` 在一个特定的 `Account` 对象上被调用，并传递了一个参数值：存款额。对象本身绑定到 `self` ，而参数绑定到 `amount` 。所有被调用的方法都可以通过 `self` 参数访问对象，因此它们都可以访问和操作对象的状态。

To invoke these methods, we again use dot notation, as illustrated below.
为了调用这些方法，我们再次使用点标记法，如下所示。

```
>>> spock_account = Account('Spock')
>>> spock_account.deposit(100)
100
>>> spock_account.withdraw(90)
10
>>> spock_account.withdraw(90)
'Insufficient funds'
>>> spock_account.holder
'Spock'
```

When a method is invoked via dot notation, the object itself (bound to `spock_account`, in this case) plays a dual role. First, it determines what the name `withdraw` means; `withdraw` is not a name in the environment, but instead a name that is local to the `Account` class. Second, it is bound to the first parameter `self` when the `withdraw` method is invoked.
当通过点标记法调用方法时，对象本身（在本例中绑定到 `spock_account` ）扮演双重角色。首先，它确定名称 `withdraw` 的含义; `withdraw` 不是环境中的名称，而是 `Account` 类的本地名称。第二，当调用 `withdraw` 方法时，它被绑定到第一个参数 `self` 。

## 2.5.3  Message Passing and Dot Expressions 2.5.3 消息传递和点表达式

Methods, which are defined in classes, and instance attributes, which are typically assigned in constructors, are the fundamental elements of object-oriented programming. These two concepts replicate much of the behavior of a dispatch dictionary in a message passing implementation of a data value. Objects take messages using dot notation, but instead of those messages being arbitrary string-valued keys, they are names local to a class. Objects also have named local state values (the instance attributes), but that state can be accessed and manipulated using dot notation, without having to employ `nonlocal` statements in the implementation.
在类中定义的方法和通常在构造函数中赋值的实例属性是面向对象编程的基本元素。这两个概念复制了数据值的消息传递实现中调度字典的许多行为。对象使用点标记法接收消息，但这些消息不是任意的字符串值键，而是类的本地名称。对象也有命名的本地状态值（实例属性），但是可以使用点标记法访问和操作该状态，而不必在实现中使用 `nonlocal` 语句。

The central idea in message passing was that data values should have behavior by responding to messages that are relevant to the abstract type they represent. Dot notation is a syntactic feature of Python that formalizes the message passing metaphor. The advantage of using a language with a built-in object system is that message passing can interact seamlessly with other language features, such as assignment statements. We do not require different messages to "get" or "set" the value associated with a local attribute name; the language syntax allows us to use the message name directly.
消息传递的中心思想是，数据值应该通过响应与它们所表示的抽象类型相关的消息来实现行为。点标记法是Python的一个语法特性，它形式化了消息传递隐喻。使用具有内置对象系统的语言的优点是消息传递可以与其他语言功能（如赋值语句）无缝地交互。我们不需要不同的消息来“获取”或“设置”与本地属性名称相关联的值;语言语法允许我们直接使用消息名称。

**Dot expressions.** The code fragment `spock_account.deposit` is called a *dot expression*. A dot expression consists of an expression, a dot, and a name:
点表达式。代码片段 `spock_account.deposit` 称为点表达式。点表达式由表达式、点和名称组成：

```
<expression> . <name>
```

The `<expression>` can be any valid Python expression, but the `<name>` must be a simple name (not an expression that evaluates to a name). A dot expression evaluates to the value of the attribute with the given `<name>`, for the object that is the value of the `<expression>`.
`<expression>` 可以是任何有效的Python表达式，但 `<name>` 必须是简单名称（不是计算结果为名称的表达式）。对于值为 `<expression>` 的对象，点表达式计算为具有给定 `<name>` 的属性的值。

The built-in function `getattr` also returns an attribute for an object by name. It is the function equivalent of dot notation. Using `getattr`, we can look up an attribute using a string, just as we did with a dispatch dictionary.
内置函数 `getattr` 还按名称返回对象的属性。它是点标记法的等效函数。使用 `getattr` ，我们可以使用字符串查找属性，就像我们使用调度字典一样。

```
>>> getattr(spock_account, 'balance')
10
```

We can also test whether an object has a named attribute with `hasattr`.
我们也可以测试对象是否有 `hasattr` 的命名属性。

```
>>> hasattr(spock_account, 'deposit')
True
```

The attributes of an object include all of its instance attributes, along with all of the attributes (including methods) defined in its class. Methods are attributes of the class that require special handling.
对象的属性包括其所有实例属性，沿着在其类中定义的所有属性（包括方法）。方法是需要特殊处理的类的属性。

**Methods and functions.** When a method is invoked on an object, that object is implicitly passed as the first argument to the method. That is, the object that is the value of the `<expression>` to the left of the dot is passed automatically as the first argument to the method named on the right side of the dot expression. As a result, the object is bound to the parameter `self`.
方法和函数。当对对象调用方法时，该对象将作为第一个参数隐式传递给该方法。也就是说，作为点左边 `<expression>` 的值的对象将作为第一个参数自动传递给点表达式右边命名的方法。结果，对象被绑定到参数 `self` 。

To achieve automatic `self` binding, Python distinguishes between *functions*, which we have been creating since the beginning of the text, and *bound methods*, which couple together a function and the object on which that method will be invoked. A bound method value is already associated with its first argument, the instance on which it was invoked, which will be named `self` when the method is called.
为了实现自动的 `self` 绑定，Python区分了函数和绑定方法，前者是我们从本书一开始就创建的，后者将函数和调用该方法的对象耦合在一起。绑定方法值已与其第一个参数关联，即调用该方法的实例，调用该方法时，该实例将命名为 `self` 。

We can see the difference in the interactive interpreter by calling `type` on the returned values of dot expressions. As an attribute of a class, a method is just a function, but as an attribute of an instance, it is a bound method:
通过对点表达式的返回值调用 `type` ，我们可以看到交互式解释器中的差异。作为类的属性，方法只是一个函数，但作为实例的属性，它是一个绑定方法：

```
>>> type(Account.deposit)
<class 'function'>
>>> type(spock_account.deposit)
<class 'method'>
```

These two results differ only in the fact that the first is a standard two-argument function with parameters `self` and `amount`. The second is a one-argument method, where the name `self` will be bound to the object named `spock_account` automatically when the method is called, while the parameter `amount` will be bound to the argument passed to the method. Both of these values, whether function values or bound method values, are associated with the same `deposit` function body.
这两个结果的不同之处仅在于第一个结果是标准的双参数函数，参数为 `self` 和 `amount` 。第二个是单参数方法，其中的名称 `self` 将在调用该方法时自动绑定到名为 `spock_account` 的对象，而参数 `amount` 将绑定到传递给该方法的参数。这两个值，无论是函数值还是绑定方法值，都与同一个 `deposit` 函数体相关联。

We can call `deposit` in two ways: as a function and as a bound method. In the former case, we must supply an argument for the `self` parameter explicitly. In the latter case, the `self` parameter is bound automatically.
我们可以通过两种方式调用 `deposit` ：作为函数和绑定方法。在前一种情况下，我们必须显式地为 `self` 参数提供一个实参。在后一种情况下， `self` 参数被自动绑定。

```
>>> Account.deposit(spock_account, 1001)  # The deposit function takes 2 arguments
1011
>>> spock_account.deposit(1000)           # The deposit method takes 1 argument
2011
```

The function `getattr` behaves exactly like dot notation: if its first argument is an object but the name is a method defined in the class, then `getattr` returns a bound method value. On the other hand, if the first argument is a class, then `getattr` returns the attribute value directly, which is a plain function.
函数 `getattr` 的行为与点表示法完全相同：如果它的第一个参数是一个对象，但名称是类中定义的方法，则 `getattr` 返回绑定的方法值。另一方面，如果第一个参数是一个类，则 `getattr` 直接返回属性值，这是一个普通函数。

**Naming Conventions.** Class names are conventionally written using the CapWords convention (also called CamelCase because the capital letters in the middle of a name look like humps). Method names follow the standard convention of naming functions using lowercased words separated by underscores.
命名约定。类名通常使用CapWords约定（也称为CamelCase，因为名称中间的大写字母看起来像驼峰）编写。方法名遵循标准的命名约定，即使用由下划线分隔的小写单词来命名函数。

In some cases, there are instance variables and methods that are related to the maintenance and consistency of an object that we don't want users of the object to see or use. They are not part of the abstraction defined by a class, but instead part of the implementation. Python's convention dictates that if an attribute name starts with an underscore, it should only be accessed within methods of the class itself, rather than by users of the class.
在某些情况下，有些实例变量和方法与对象的维护和一致性有关，我们不希望对象的用户看到或使用它们。它们不是类定义的抽象的一部分，而是实现的一部分。Python的约定规定，如果属性名以下划线开头，那么它只能在类本身的方法中访问，而不能由类的用户访问。

## 2.5.4  Class Attributes 2.5.4 类属性

Some attribute values are shared across all objects of a given class. Such attributes are associated with the class itself, rather than any individual instance of the class. For instance, let us say that a bank pays interest on the balance of accounts at a fixed interest rate. That interest rate may change, but it is a single value shared across all accounts.
某些属性值在给定类的所有对象之间共享。此类属性与类本身相关联，而不是与类的任何单个实例相关联。例如，我们假设一家银行按固定利率对账户余额支付利息。这个利率可能会改变，但它是所有账户共享的单一价值。

Class attributes are created by assignment statements in the suite of a `class` statement, outside of any method definition. In the broader developer community, class attributes may also be called class variables or static variables. The following class statement creates a class attribute for `Account` with the name `interest`.
类属性由 `class` 语句套件中的赋值语句创建，在任何方法定义之外。在更广泛的开发人员社区中，类属性也可以称为类变量或静态变量。下面的class语句为 `Account` 创建名为 `interest` 的class属性。

```
>>> class Account:
        interest = 0.02            # A class attribute
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
        # Additional methods would be defined here
```

This attribute can still be accessed from any instance of the class.
仍然可以从类的任何实例访问此属性。

```
>>> spock_account = Account('Spock')
>>> kirk_account = Account('Kirk')
>>> spock_account.interest
0.02
>>> kirk_account.interest
0.02
```

However, a single assignment statement to a class attribute changes the value of the attribute for all instances of the class.
但是，对class属性的单个赋值语句会更改该类所有实例的属性值。

```
>>> Account.interest = 0.04
>>> spock_account.interest
0.04
>>> kirk_account.interest
0.04
```

**Attribute names.** We have introduced enough complexity into our object system that we have to specify how names are resolved to particular attributes. After all, we could easily have a class attribute and an instance attribute with the same name.
属性名称。我们已经在对象系统中引入了足够的复杂性，以至于我们必须指定如何将名称解析为特定的属性。毕竟，我们可以很容易地拥有同名的类属性和实例属性。

As we have seen, a dot expression consists of an expression, a dot, and a name:
正如我们所看到的，点表达式由表达式、点和名称组成：

```
<expression> . <name>
```

To evaluate a dot expression: 要计算点表达式：

1. Evaluate the `<expression>` to the left of the dot, which yields the *object* of the dot expression.
    计算点左侧的 `<expression>` ，这将生成点表达式的对象。
2. `<name>` is matched against the instance attributes of that object; if an attribute with that name exists, its value is returned.
    `<name>` 与该对象的实例属性匹配;如果具有该名称的属性存在，则返回其值。
3. If `<name>` does not appear among instance attributes, then `<name>` is looked up in the class, which yields a class attribute value.
    如果 `<name>` 没有出现在实例属性中，则在类中查找 `<name>` ，这将产生一个类属性值。
4. That value is returned unless it is a function, in which case a bound method is returned instead.
    除非该值是函数，否则将返回该值，在这种情况下，将返回绑定方法。

In this evaluation procedure, instance attributes are found before class attributes, just as local names have priority over global in an environment. Methods defined within the class are combined with the object of the dot expression to form a bound method during the fourth step of this evaluation procedure. The procedure for looking up a name in a class has additional nuances that will arise shortly, once we introduce class inheritance.
在这个评估过程中，实例属性在类属性之前被找到，就像在环境中局部名称优先于全局名称一样。在这个求值过程的第四步中，类中定义的方法与点表达式的对象组合在一起，形成一个绑定方法。在类中查找名字的过程还有一些细微差别，一旦我们引入了类继承，这些差别很快就会出现。

**Attribute assignment.** All assignment statements that contain a dot expression on their left-hand side affect attributes for the object of that dot expression. If the object is an instance, then assignment sets an instance attribute. If the object is a class, then assignment sets a class attribute. As a consequence of this rule, assignment to an attribute of an object cannot affect the attributes of its class. The examples below illustrate this distinction.
属性赋值。左侧包含点表达式的所有赋值语句都会影响该点表达式的对象的属性。如果对象是一个实例，则赋值设置一个实例属性。如果对象是一个类，则赋值设置一个类属性。由于这一规则，对对象属性的赋值不能影响其类的属性。下面的例子说明了这一区别。

If we assign to the named attribute `interest` of an account instance, we create a new instance attribute that has the same name as the existing class attribute.
如果我们为帐户实例的命名属性 `interest` 赋值，则会创建一个与现有类属性同名的新实例属性。

```
>>> kirk_account.interest = 0.08
```

and that attribute value will be returned from a dot expression.
并且该属性值将从点表达式返回。

```
>>> kirk_account.interest
0.08
```

However, the class attribute `interest` still retains its original value, which is returned for all other accounts.
但是，类属性 `interest` 仍保留其原始值，该值将为所有其他帐户返回。

```
>>> spock_account.interest
0.04
```

Changes to the class attribute `interest` will affect `spock_account`, but the instance attribute for `kirk_account` will be unaffected.
对类属性 `interest` 的更改将影响 `spock_account` ，但 `kirk_account` 的实例属性不受影响。

```
>>> Account.interest = 0.05  # changing the class attribute
>>> spock_account.interest     # changes instances without like-named instance attributes
0.05
>>> kirk_account.interest     # but the existing instance attribute is unaffected
0.08
```

## 2.5.5  Inheritance 2.5.5 继承

When working in the object-oriented programming paradigm, we often find that different types are related. In particular, we find that similar classes differ in their amount of specialization. Two classes may have similar attributes, but one represents a special case of the other.
当在面向对象编程范例中工作时，我们经常发现不同的类型是相关的。特别是，我们发现相似的类在它们的专门化程度上是不同的。两个类可能具有相似的属性，但其中一个代表另一个的特殊情况。

For example, we may want to implement a checking account, which is different from a standard account. A checking account charges an extra $1 for each withdrawal and has a lower interest rate. Here, we demonstrate the desired behavior.
例如，我们可能希望实现一个支票帐户，它与标准帐户不同。支票账户每次取款要多收1美元，而且利率较低。在这里，我们演示所需的行为。

```
>>> ch = CheckingAccount('Spock')
>>> ch.interest     # Lower interest rate for checking accounts
0.01
>>> ch.deposit(20)  # Deposits are the same
20
>>> ch.withdraw(5)  # withdrawals decrease balance by an extra charge
14
```

A `CheckingAccount` is a specialization of an `Account`. In OOP terminology, the generic account will serve as the base class of `CheckingAccount`, while `CheckingAccount` will be a subclass of `Account`. (The terms *parent class* and *superclass* are also used for the base class, while *child class* is also used for the subclass.)
`CheckingAccount` 是 `Account` 的特殊化。在OOP术语中，泛型帐户将作为 `CheckingAccount` 的基类，而 `CheckingAccount` 将是 `Account` 的子类。(The术语父类和超类也用于基类，而子类也用于子类）。

A subclass *inherits* the attributes of its base class, but may *override* certain attributes, including certain methods. With inheritance, we only specify what is different between the subclass and the base class. Anything that we leave unspecified in the subclass is automatically assumed to behave just as it would for the base class.
子类继承其基类的属性，但可以重写某些属性，包括某些方法。对于继承，我们只指定子类和基类之间的不同之处。我们在子类中未指定的任何内容都将自动假定为与基类相同的行为。

Inheritance also has a role in our object metaphor, in addition to being a useful organizational feature. Inheritance is meant to represent *is-a* relationships between classes, which contrast with *has-a* relationships. A checking account *is-a* specific type of account, so having a `CheckingAccount` inherit from `Account` is an appropriate use of inheritance. On the other hand, a bank *has-a* list of bank accounts that it manages, so neither should inherit from the other. Instead, a list of account objects would be naturally expressed as an instance attribute of a bank object.
继承除了是一个有用的组织特征之外，在我们的对象隐喻中也有一定的作用。继承意味着表示类之间的“是”关系，这与“有”关系相反。支票帐户是一种特定类型的帐户，因此从 `Account` 继承 `CheckingAccount` 是继承的适当用途。另一方面，银行有它管理的银行帐户列表，因此任何一方都不应继承对方。相反，account对象的列表将自然地表示为bank对象的实例属性。

## 2.5.6  Using Inheritance 2.5.6 使用继承

First, we give a full implementation of the `Account` class, which includes docstrings for the class and its methods.
首先，我们给予了 `Account` 类的完整实现，其中包括类及其方法的文档字符串。

```
>>> class Account:
        """A bank account that has a non-negative balance."""
        interest = 0.02
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
        def deposit(self, amount):
            """Increase the account balance by amount and return the new balance."""
            self.balance = self.balance + amount
            return self.balance
        def withdraw(self, amount):
            """Decrease the account balance by amount and return the new balance."""
            if amount > self.balance:
                return 'Insufficient funds'
            self.balance = self.balance - amount
            return self.balance
```

A full implementation of `CheckingAccount` appears below. We specify inheritance by placing an expression that evaluates to the base class in parentheses after the class name.
`CheckingAccount` 的完整实现如下所示。我们通过在类名后面的圆括号中放置一个计算结果为基类的表达式来指定继承。

```
>>> class CheckingAccount(Account):
        """A bank account that charges for withdrawals."""
        withdraw_charge = 1
        interest = 0.01
        def withdraw(self, amount):
            return Account.withdraw(self, amount + self.withdraw_charge)
```

Here, we introduce a class attribute `withdraw_charge` that is specific to the `CheckingAccount` class. We assign a lower value to the `interest` attribute. We also define a new `withdraw` method to override the behavior defined in the `Account` class. With no further statements in the class suite, all other behavior is inherited from the base class `Account`.
这里，我们引入一个类属性 `withdraw_charge` ，它是 `CheckingAccount` 类所特有的。我们为 `interest` 属性分配一个较低的值。我们还定义了一个新的 `withdraw` 方法来覆盖 `Account` 类中定义的行为。由于类套件中没有其他语句，所有其他行为都是从基类 `Account` 继承的。

```
>>> checking = CheckingAccount('Sam')
>>> checking.deposit(10)
10
>>> checking.withdraw(5)
4
>>> checking.interest
0.01
```

The expression `checking.deposit` evaluates to a bound method for making deposits, which was defined in the `Account` class. When Python resolves a name in a dot expression that is not an attribute of the instance, it looks up the name in the class. In fact, the act of "looking up" a name in a class tries to find that name in every base class in the inheritance chain for the original object's class. We can define this procedure recursively. To look up a name in a class.
表达式 `checking.deposit` 的计算结果为 `Account` 类中定义的用于存款的绑定方法。当Python解析一个点表达式中的名称时，它不是实例的属性，它会在类中查找该名称。实际上，在类中“查找”名称的行为试图在原始对象的类的继承链中的每个基类中找到该名称。我们可以递归地定义这个过程。在类中查找名称。

1. If it names an attribute in the class, return the attribute value.
    如果它命名类中的属性，则返回属性值。
2. Otherwise, look up the name in the base class, if there is one.
    否则，在基类中查找该名称（如果有）。

In the case of `deposit`, Python would have looked for the name first on the instance, and then in the `CheckingAccount` class. Finally, it would look in the `Account` class, where `deposit` is defined. According to our evaluation rule for dot expressions, since `deposit` is a function looked up in the class for the `checking` instance, the dot expression evaluates to a bound method value. That method is invoked with the argument 10, which calls the deposit method with `self` bound to the `checking` object and `amount` bound to 10.
在 `deposit` 的情况下，Python会先在实例中查找名称，然后在 `CheckingAccount` 类中查找。最后，它将在 `Account` 类中查找，其中定义了 `deposit` 。根据点表达式的求值规则，由于 `deposit` 是在类中为 `checking` 实例查找的函数，因此点表达式求值为绑定方法值。该方法用参数10调用，参数10调用存款方法， `self` 绑定到 `checking` 对象， `amount` 绑定到10。

The class of an object stays constant throughout. Even though the `deposit` method was found in the `Account` class, `deposit` is called with `self` bound to an instance of `CheckingAccount`, not of `Account`.
对象的类始终保持不变。即使在 `Account` 类中找到了 `deposit` 方法，但调用 `deposit` 时 `self` 绑定到 `CheckingAccount` 的实例，而不是 `Account` 的实例。

**Calling ancestors.** Attributes that have been overridden are still accessible via class objects. For instance, we implemented the `withdraw` method of `CheckingAccount` by calling the `withdraw` method of `Account` with an argument that included the `withdraw_charge`.
呼唤祖先。被覆盖的属性仍然可以通过类对象访问。例如，我们通过使用包含 `withdraw_charge` 的参数调用 `Account` 的 `withdraw` 方法来实现 `CheckingAccount` 的 `withdraw` 方法。

Notice that we called `self.withdraw_charge` rather than the equivalent `CheckingAccount.withdraw_charge`. The benefit of the former over the latter is that a class that inherits from `CheckingAccount` might override the withdrawal charge. If that is the case, we would like our implementation of `withdraw` to find that new value instead of the old one.
注意，我们调用了 `self.withdraw_charge` 而不是等价的 `CheckingAccount.withdraw_charge` 。前者相对于后者的好处在于，从 `CheckingAccount` 继承的类可能会覆盖取款费用。如果是这种情况，我们希望 `withdraw` 的实现找到新值而不是旧值。

**Interfaces.** It is extremely common in object-oriented programs that different types of objects will share the same attribute names. An *object interface* is a collection of attributes and conditions on those attributes. For example, all accounts must have `deposit` and `withdraw` methods that take numerical arguments, as well as a `balance` attribute. The classes `Account` and `CheckingAccount` both implement this interface. Inheritance specifically promotes name sharing in this way. In some programming languages such as Java, interface implementations must be explicitly declared. In others such as Python, Ruby, and Go, any object with the appropriate names implements an interface.
接口。在面向对象的程序中，不同类型的对象共享相同的属性名是非常常见的。对象接口是属性和这些属性上的条件的集合。例如，所有帐户都必须具有接受数字参数的 `deposit` 和 `withdraw` 方法以及 `balance` 属性。类 `Account` 和 `CheckingAccount` 都实现了这个接口。继承特别以这种方式促进名称共享。在一些编程语言中，如Java，接口实现必须显式声明。在Python、Ruby和Go语言中，任何具有适当名称的对象都实现了接口。

The parts of your program that use objects (rather than implementing them) are most robust to future changes if they do not make assumptions about object types, but instead only about their attribute names. That is, they use the object abstraction, rather than assuming anything about its implementation.
如果程序中使用对象（而不是实现对象）的部分不假设对象类型，而只假设对象的属性名称，则它们对未来的更改最为健壮。也就是说，它们使用对象抽象，而不是假设任何关于其实现的东西。

For example, let us say that we run a lottery, and we wish to deposit $5 into each of a list of accounts. The following implementation does not assume anything about the types of those accounts, and therefore works equally well with any type of object that has a `deposit` method:
例如，假设我们运行一个彩票，并且我们希望向一个帐户列表中的每个帐户存款$5。下面的实现没有假设任何有关这些帐户类型的信息，因此同样适用于具有 `deposit` 方法的任何类型的对象：

```
>>> def deposit_all(winners, amount=5):
        for account in winners:
            account.deposit(amount)
```

The function `deposit_all` above assumes only that each `account` satisfies the account object abstraction, and so it will work with any other account classes that also implement this interface. Assuming a particular class of account would violate the abstraction barrier of the account object abstraction. For example, the following implementation will not necessarily work with new kinds of accounts:
上面的函数 `deposit_all` 只假设每个 `account` 满足帐户对象抽象，因此它将与也实现此接口的任何其他帐户类一起工作。假设帐户的特定类将违反帐户对象抽象的抽象屏障。例如，以下实现不一定适用于新类型的帐户：

```
>>> def deposit_all(winners, amount=5):
        for account in winners:
            Account.deposit(account, amount)
```

We will address this topic in more detail later in the chapter.
我们将在本章后面更详细地讨论这个主题。

## 2.5.7  Multiple Inheritance 2.5.7 多重遗传

Python supports the concept of a subclass inheriting attributes from multiple base classes, a language feature called *multiple inheritance*.
Python支持子类从多个基类继承属性的概念，这种语言特性称为多重继承。

Suppose that we have a `SavingsAccount` that inherits from `Account`, but charges customers a small fee every time they make a deposit.
假设我们有一个 `SavingsAccount` ，它继承自 `Account` ，但每次客户存款时都要收取少量费用。

```
>>> class SavingsAccount(Account):
        deposit_charge = 2
        def deposit(self, amount):
            return Account.deposit(self, amount - self.deposit_charge)
```

Then, a clever executive conceives of an `AsSeenOnTVAccount` account with the best features of both `CheckingAccount` and `SavingsAccount`: withdrawal fees, deposit fees, and a low interest rate. It's both a checking and a savings account in one! "If we build it," the executive reasons, "someone will sign up and pay all those fees. We'll even give them a dollar."
然后，一位聪明的管理人员会构思出一个同时具备 `CheckingAccount` 和 `SavingsAccount` 最佳特征的 `AsSeenOnTVAccount` 客户：取款费、存款费和低利率。它既是支票帐户又是储蓄帐户！“如果我们建造它，”这位高管解释说，“就会有人签约并支付所有这些费用。我们甚至会给予他们一块钱。“

```
>>> class AsSeenOnTVAccount(CheckingAccount, SavingsAccount):
        def __init__(self, account_holder):
            self.holder = account_holder
            self.balance = 1           # A free dollar!
```

In fact, this implementation is complete. Both withdrawal and deposits will generate fees, using the function definitions in `CheckingAccount` and `SavingsAccount` respectively.
实际上，这个实现是完整的。取款和存款都会产生费用，分别使用 `CheckingAccount` 和 `SavingsAccount` 中的函数定义。

```
>>> such_a_deal = AsSeenOnTVAccount("John")
>>> such_a_deal.balance
1
>>> such_a_deal.deposit(20)            # $2 fee from SavingsAccount.deposit
19
>>> such_a_deal.withdraw(5)            # $1 fee from CheckingAccount.withdraw
13
```

Non-ambiguous references are resolved correctly as expected:
明确的引用按预期正确解析：

```
>>> such_a_deal.deposit_charge
2
>>> such_a_deal.withdraw_charge
1
```

But what about when the reference is ambiguous, such as the reference to the `withdraw` method that is defined in both `Account` and `CheckingAccount`? The figure below depicts an *inheritance graph* for the `AsSeenOnTVAccount` class. Each arrow points from a subclass to a base class.
但是如果引用不明确，比如对 `Account` 和 `CheckingAccount` 中都定义了的 `withdraw` 方法的引用，那该怎么办呢？下图描述了 `AsSeenOnTVAccount` 类的继承图。每个箭头从子类指向基类。

![multiple_inheritance](/sicp-python/multiple_inheritance.png)

For a simple "diamond" shape like this, Python resolves names from left to right, then upwards. In this example, Python checks for an attribute name in the following classes, in order, until an attribute with that name is found:
对于这样一个简单的“菱形”形状，Python从左到右，然后向上解析名称。在这个例子中，Python按顺序检查以下类中的属性名称，直到找到具有该名称的属性：

```
AsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, object
```

There is no correct solution to the inheritance ordering problem, as there are cases in which we might prefer to give precedence to certain inherited classes over others. However, any programming language that supports multiple inheritance must select some ordering in a consistent way, so that users of the language can predict the behavior of their programs.
对于继承顺序问题没有正确的解决方案，因为在某些情况下，我们可能更愿意给予某些继承类比其他继承类更高的优先级。但是，任何支持多重继承的编程语言都必须以一致的方式选择某种排序，以便语言的用户可以预测其程序的行为。

**Further reading.** Python resolves this name using a recursive algorithm called the C3 Method Resolution Ordering. The method resolution order of any class can be queried using the `mro` method on all classes.
进一步阅读。Python使用一种称为C3方法解析排序的递归算法来解析这个名称。可以使用所有类上的 `mro` 方法查询任何类的方法解析顺序。

```
>>> [c.__name__ for c in AsSeenOnTVAccount.mro()]
['AsSeenOnTVAccount', 'CheckingAccount', 'SavingsAccount', 'Account', 'object']
```

The precise algorithm for finding method resolution orderings is not a topic for this text, but is [described by Python's primary author](http://python-history.blogspot.com/2010/06/method-resolution-order.html) with a reference to the original paper.
查找方法分解排序的精确算法不是本文的主题，而是由Python的主要作者通过参考原始论文来描述的。

## 2.5.8  The Role of Objects 2.5.8 对象的作用

The Python object system is designed to make data abstraction and message passing both convenient and flexible. The specialized syntax of classes, methods, inheritance, and dot expressions all enable us to formalize the object metaphor in our programs, which improves our ability to organize large programs.
Python对象系统旨在使数据抽象和消息传递既方便又灵活。类、方法、继承和点表达式的专门语法都使我们能够形式化程序中的对象隐喻，这提高了我们组织大型程序的能力。

In particular, we would like our object system to promote a *separation of concerns* among the different aspects of the program. Each object in a program encapsulates and manages some part of the program's state, and each class statement defines the functions that implement some part of the program's overall logic. Abstraction barriers enforce the boundaries between different aspects of a large program.
特别是，我们希望我们的对象系统能够促进程序不同方面之间关注点的分离。程序中的每个对象都封装和管理程序状态的某一部分，每个class语句定义实现程序总体逻辑某一部分的函数。抽象屏障加强了大型程序不同方面之间的界限。

Object-oriented programming is particularly well-suited to programs that model systems that have separate but interacting parts. For instance, different users interact in a social network, different characters interact in a game, and different shapes interact in a physical simulation. When representing such systems, the objects in a program often map naturally onto objects in the system being modeled, and classes represent their types and relationships.
面向对象编程特别适合于对具有独立但相互作用的部分的系统建模的程序。例如，不同的用户在社交网络中交互，不同的角色在游戏中交互，以及不同的形状在物理模拟中交互。当表示这样的系统时，程序中的对象通常自然地映射到正在建模的系统中的对象，而类表示它们的类型和关系。

On the other hand, classes may not provide the best mechanism for implementing certain abstractions. Functional abstractions provide a more natural metaphor for representing relationships between inputs and outputs. One should not feel compelled to fit every bit of logic in a program within a class, especially when defining independent functions for manipulating data is more natural. Functions can also enforce a separation of concerns.
另一方面，类可能没有提供实现某些抽象的最佳机制。功能抽象为表示输入和输出之间的关系提供了更自然的隐喻。人们不应该感到必须将程序中的每一位逻辑都放在类中，特别是当定义独立函数来操作数据更自然时。功能还可以强制分离关注点。

Multi-paradigm languages such as Python allow programmers to match organizational paradigms to appropriate problems. Learning to identify when to introduce a new class, as opposed to a new function, in order to simplify or modularize a program, is an important design skill in software engineering that deserves careful attention.
多范式语言（如Python）允许程序员将组织范式与适当的问题相匹配。学会识别何时引入一个新类，而不是一个新函数，以便简化或模块化程序，是软件工程中一项重要的设计技能，值得仔细关注。