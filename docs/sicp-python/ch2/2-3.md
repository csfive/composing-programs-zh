# 2.3 序列

:::info
译者：

来源：[2.3 Sequences](http://composingprograms.com/pages/23-sequences.html)

对应：Disc 04、Lab 04、Cats、Disc 06
:::




A sequence is an ordered collection of values. The sequence is a powerful, fundamental abstraction in computer science. Sequences are not instances of a particular built-in type or abstract data representation, but instead a collection of behaviors that are shared among several different types of data. That is, there are many kinds of sequences, but they all share common behavior. In particular,

序列是值的有序集合。序列是计算机科学中一个强大的、基本的抽象概念。序列不是特定内置类型或抽象数据表示的实例，而是在几种不同类型的数据之间共享的行为集合。也就是说，有很多种序列，但它们都有共同的行为。尤其，

**Length.** A sequence has a finite length. An empty sequence has length 0.

长度。序列的长度是有限的。空序列的长度为 0。

**Element selection.** A sequence has an element corresponding to any non-negative integer index less than its length, starting at 0 for the first element.

元素选择。一个序列有一个元素对应于任何小于其长度的非负整数索引，第一个元素从 0 开始。

Python includes several native data types that are sequences, the most important of which is the `list`.

Python 包括几种本机数据类型，它们是序列，其中最重要的是 `list` 。

## 2.3.1  Lists 2.3.1 列表

A `list` value is a sequence that can have arbitrary length. Lists have a large set of built-in behaviors, along with specific syntax to express those behaviors. We have already seen the list literal, which evaluates to a `list` instance, as well as an element selection expression that evaluates to a value in the list. The built-in `len` function returns the length of a sequence. Below, `digits` is a list with four elements. The element at index 3 is 8.

`list` 值是一个可以具有任意长度的序列。列表有大量的内置行为，以及表达这些行为的特定语法。我们已经看到了列表文字，它的计算结果是一个 `list` 实例，以及一个元素选择表达式，它的计算结果是列表中的一个值。内置的 `len` 函数返回序列的长度。下面， `digits` 是一个包含四个元素的列表。索引 3 处的元素为 8。

```py
>>> digits = [1, 8, 2, 8]
>>> len(digits)
4
>>> digits[3]
8
```

Additionally, lists can be added together and multiplied by integers. For sequences, addition and multiplication do not add or multiply elements, but instead combine and replicate the sequences themselves. That is, the `add` function in the `operator` module (and the `+` operator) yields a list that is the concatenation of the added arguments. The `mul` function in `operator` (and the `*` operator) can take a list and an integer `k` to return the list that consists of `k` repetitions of the original list.

此外，列表可以相加并乘以整数。对于序列，加法和乘法并不是对元素进行加法或乘法运算，而是对序列本身进行组合和复制。也就是说， `operator` 模块中的 `add` 函数（和 `+` 运算符）生成一个列表，该列表是添加的参数的串联。 `operator` 中的 `mul` 函数（和 `*` 运算符）可以采用一个列表和一个整数 `k` 来返回由原始列表的 `k` 重复组成的列表。

```py
>>> [2, 7] + digits * 2
[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]
```

Any values can be included in a list, including another list. Element selection can be applied multiple times in order to select a deeply nested element in a list containing lists.

任何值都可以包含在一个列表中，包括另一个列表。可以多次应用元素选择，以便在包含列表的列表中选择深度嵌套的元素。

```py
>>> pairs = [[10, 20], [30, 40]]
>>> pairs[1]
[30, 40]
>>> pairs[1][0]
30
```

## 2.3.2  Sequence Iteration 2.3.2 序列迭代

In many cases, we would like to iterate over the elements of a sequence and perform some computation for each element in turn. This pattern is so common that Python has an additional control statement to process sequential data: the `for` statement.

在许多情况下，我们希望遍历序列的元素并依次对每个元素执行一些计算。这种模式非常普遍，以至于 Python 有一个额外的控制语句来处理顺序数据： `for` 语句。

Consider the problem of counting how many times a value appears in a sequence. We can implement a function to compute this count using a `while` loop.

考虑计算一个值在序列中出现多少次的问题。我们可以实现一个函数来使用 `while` 循环来计算此计数。

```py
>>> def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total, index = 0, 0
        while index < len(s):
            if s[index] == value:
                total = total + 1
            index = index + 1
        return total
    
>>> count(digits, 8)
2
```

The Python `for` statement can simplify this function body by iterating over the element values directly without introducing the name `index` at all.

Python `for` 语句可以通过直接遍历元素值来简化此函数体，而根本不引入名称 `index` 。

```py
>>> def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total = 0
        for elem in s:
            if elem == value:
                total = total + 1
        return total
    
>>> count(digits, 8)
2
```

A `for` statement consists of a single clause with the form:

`for` 语句由具有以下形式的单个子句组成：

```py
for <name> in <expression>:
    <suite>
```

A `for` statement is executed by the following procedure:

`for` 语句由以下过程执行：

1. Evaluate the header `<expression>`, which must yield an iterable value.
2. 评估标头 `<expression>` ，它必须产生一个可迭代的值。
3. For each element value in that iterable value, in order:
4. 对于该可迭代值中的每个元素值，按顺序：
    1. Bind `<name>` to that value in the current frame.
    2. 将 `<name>` 绑定到当前帧中的那个值。
    3. Execute the `<suite>`. 
    4. 执行 `<suite>` 。

This execution procedure refers to *iterable values*. Lists are a type of sequence, and sequences are iterable values. Their elements are considered in their sequential order. Python includes other iterable types, but we will focus on sequences for now; the general definition of the term "iterable" appears in the section on iterators in Chapter 4.

此执行过程引用可迭代值。列表是一种序列，序列是可迭代的值。它们的元素按顺序考虑。 Python 包括其他可迭代类型，但我们现在将重点关注序列；术语“可迭代”的一般定义出现在第 4 章的迭代器部分。

An important consequence of this evaluation procedure is that `<name>` will be bound to the last element of the sequence after the `for` statement is executed. The `for` loop introduces yet another way in which the environment can be updated by a statement.

此评估过程的一个重要结果是 `<name>` 将在执行 `for` 语句后绑定到序列的最后一个元素。 `for` 循环引入了另一种可以通过语句更新环境的方法。

**Sequence unpacking.** A common pattern in programs is to have a sequence of elements that are themselves sequences, but all of a fixed length. A `for` statement may include multiple names in its header to "unpack" each element sequence into its respective elements. For example, we may have a list of two-element lists.

顺序解包。程序中的一个常见模式是拥有一个元素序列，这些元素本身就是序列，但长度都是固定的。 `for` 语句可以在其标头中包含多个名称，以将每个元素序列“解包”到其各自的元素中。例如，我们可能有一个包含两个元素的列表。

```py
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
```

and wish to find the number of these pairs that have the same first and second element.

并希望找到具有相同第一和第二元素的这些对的数量。

```py
>>> same_count = 0
```

The following `for` statement with two names in its header will bind each name `x` and `y` to the first and second elements in each pair, respectively.

下面的 `for` 语句在其标头中包含两个名称，会将每个名称 `x` 和 `y` 分别绑定到每对中的第一个和第二个元素。

```py
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
            
>>> same_count
2
```

This pattern of binding multiple names to multiple values in a fixed-length sequence is called *sequence unpacking*; it is the same pattern that we see in assignment statements that bind multiple names to multiple values.

这种将多个名称绑定到固定长度序列中的多个值的模式称为序列拆包；这与我们在将多个名称绑定到多个值的赋值语句中看到的模式相同。

**Ranges.** A `range` is another built-in type of sequence in Python, which represents a range of integers. Ranges are created with `range`, which takes two integer arguments: the first number and one beyond the last number in the desired range.

范围。 `range` 是 Python 中的另一种内置序列类型，它表示一个整数范围。范围是用 `range` 创建的，它有两个整数参数：第一个数字和超出所需范围内最后一个数字的数字。

```py
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)
```

Calling the `list` constructor on a range evaluates to a list with the same elements as the range, so that the elements can be easily inspected.

在范围上调用 `list` 构造函数会计算出具有与范围相同的元素的列表，以便可以轻松检查元素。

```py
>>> list(range(5, 8))
[5, 6, 7]
```

If only one argument is given, it is interpreted as one beyond the last value for a range that starts at 0.

如果只给出一个参数，它被解释为超出从 0 开始的范围的最后一个值。

```py
>>> list(range(4))
[0, 1, 2, 3]
```

Ranges commonly appear as the expression in a `for` header to specify the number of times that the suite should be executed: A common convention is to use a single underscore character for the name in the `for` header if the name is unused in the suite:

范围通常显示为 `for` 标头中的表达式，以指定套件应执行的次数：如果名称未在套房：

```py
>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

This underscore is just another name in the environment as far as the interpreter is concerned, but has a conventional meaning among programmers that indicates the name will not appear in any future expressions.

就解释器而言，下划线只是环境中的另一个名称，但在程序员中具有约定俗成的含义，表示该名称不会出现在任何未来的表达式中。

## 2.3.3  Sequence Processing 2.3.3 序列处理

Sequences are such a common form of compound data that whole programs are often organized around this single abstraction. Modular components that have sequences as both inputs and outputs can be mixed and matched to perform data processing. Complex components can be defined by chaining together a pipeline of sequence processing operations, each of which is simple and focused.

序列是复合数据的一种常见形式，以至于整个程序通常都是围绕这个单一的抽象来组织的。具有序列作为输入和输出的模块化组件可以混合和匹配以执行数据处理。可以通过将序列处理操作的管道链接在一起来定义复杂的组件，每个操作都很简单且有针对性。

**List Comprehensions.** Many sequence processing operations can be expressed by evaluating a fixed expression for each element in a sequence and collecting the resulting values in a result sequence. In Python, a list comprehension is an expression that performs such a computation.

列表理解。许多序列处理操作可以通过为序列中的每个元素评估固定表达式并将结果值收集在结果序列中来表达。在 Python 中，列表理解是执行此类计算的表达式。

```py
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

The `for` keyword above is not part of a `for` statement, but instead part of a list comprehension because it is contained within square brackets. The sub-expression `x+1` is evaluated with `x` bound to each element of `odds` in turn, and the resulting values are collected into a list.

上面的 `for` 关键字不是 `for` 语句的一部分，而是列表理解的一部分，因为它包含在方括号中。子表达式 `x+1` 依次通过绑定到 `odds` 的每个元素的 `x` 进行求值，并将结果值收集到一个列表中。

Another common sequence processing operation is to select a subset of values that satisfy some condition. List comprehensions can also express this pattern, for instance selecting all elements of `odds` that evenly divide `25`.

另一个常见的序列处理操作是选择满足某些条件的值的子集。列表推导式也可以表达这种模式，例如选择 `odds` 中均匀划分 `25` 的所有元素。

```py
>>> [x for x in odds if 25 % x == 0]
[1, 5]
```

The general form of a list comprehension is:

列表理解的一般形式是：

```py
[<map expression> for <name> in <sequence expression> if <filter expression>]
```

To evaluate a list comprehension, Python evaluates the `<sequence expression>`, which must return an iterable value. Then, for each element in order, the element value is bound to `<name>`, the filter expression is evaluated, and if it yields a true value, the map expression is evaluated. The values of the map expression are collected into a list.

为了评估列表理解，Python 评估 `<sequence expression>` ，它必须返回一个可迭代的值。然后，对于顺序中的每个元素，元素值绑定到 `<name>` ，过滤器表达式被评估，如果它产生一个真值，映射表达式被评估。映射表达式的值被收集到一个列表中。

**Aggregation.** A third common pattern in sequence processing is to aggregate all values in a sequence into a single value. The built-in functions `sum`, `min`, and `max` are all examples of aggregation functions.

聚合。序列处理中的第三种常见模式是将序列中的所有值聚合为一个值。内置函数 `sum` 、 `min` 和 `max` 都是聚合函数的示例。

By combining the patterns of evaluating an expression for each element, selecting a subset of elements, and aggregating elements, we can solve problems using a sequence processing approach.

通过结合为每个元素评估表达式、选择元素子集和聚合元素的模式，我们可以使用序列处理方法解决问题。

A perfect number is a positive integer that is equal to the sum of its divisors. The divisors of `n` are positive integers less than `n` that divide evenly into `n`. Listing the divisors of `n` can be expressed with a list comprehension.

完美数是等于其约数之和的正整数。 `n` 的除数是小于 `n` 的正整数，可以将 `n` 整除。列出 `n` 的除数可以用列表理解来表示。

```py
>>> def divisors(n):
        return [1] + [x for x in range(2, n) if n % x == 0]
>>> divisors(4)
[1, 2]
>>> divisors(12)
[1, 2, 3, 4, 6]
```

Using `divisors`, we can compute all perfect numbers from 1 to 1000 with another list comprehension. (1 is typically considered to be a perfect number as well, but it does not qualify under our definition of `divisors`.)

使用 `divisors` ，我们可以使用另一个列表理解来计算从 1 到 1000 的所有完美数字。 （1 通常也被认为是一个完美的数字，但它不符合我们对 `divisors` 的定义。）

```py
>>> [n for n in range(1, 1000) if sum(divisors(n)) == n]
[6, 28, 496]
```

We can reuse our definition of `divisors` to solve another problem, finding the minimum perimeter of a rectangle with integer side lengths, given its area. The area of a rectangle is its height times its width. Therefore, given the area and height, we can compute the width. We can assert that both the width and height evenly divide the area to ensure that the side lengths are integers.

我们可以重用 `divisors` 的定义来解决另一个问题，即在给定面积的情况下找到具有整数边长的矩形的最小周长。矩形的面积是它的高乘以它的宽。因此，给定面积和高度，我们可以计算出宽度。我们可以断言，宽度和高度都平分面积，保证边长是整数。

```py
>>> def width(area, height):
        assert area % height == 0
        return area // height
```

The perimeter of a rectangle is the sum of its side lengths.

矩形的周长是其边长的总和。

```py
>>> def perimeter(width, height):
        return 2 * width + 2 * height
```

The height of a rectangle with integer side lengths must be a divisor of its area. We can compute the minimum perimeter by considering all heights.

边长为整数的矩形的高度必须是其面积的约数。我们可以通过考虑所有高度来计算最小周长。

```py
>>> def minimum_perimeter(area):
        heights = divisors(area)
        perimeters = [perimeter(width(area, h), h) for h in heights]
        return min(perimeters)
>>> area = 80
>>> width(area, 5)
16
>>> perimeter(16, 5)
42
>>> perimeter(10, 8)
36
>>> minimum_perimeter(area)
36
>>> [minimum_perimeter(n) for n in range(1, 10)]
[4, 6, 8, 8, 12, 10, 16, 12, 12]
```

**Higher-Order Functions.** The common patterns we have observed in sequence processing can be expressed using higher-order functions. First, evaluating an expression for each element in a sequence can be expressed by applying a function to each element.

高阶函数。我们在序列处理中观察到的常见模式可以使用高阶函数来表示。首先，可以通过将函数应用于每个元素来表达对序列中每个元素的表达式求值。

```py
>>> def apply_to_all(map_fn, s):
        return [map_fn(x) for x in s]
```

Selecting only elements for which some expression is true can be expressed by applying a function to each element.

仅选择某些表达式为真的元素可以通过对每个元素应用一个函数来表达。

```py
>>> def keep_if(filter_fn, s):
        return [x for x in s if filter_fn(x)]
```

Finally, many forms of aggregation can be expressed as repeatedly applying a two-argument function to the `reduced` value so far and each element in turn.

最后，许多形式的聚合可以表示为将双参数函数重复应用到 `reduced` 值，并依次应用到每个元素。

```py
>>> def reduce(reduce_fn, s, initial):
        reduced = initial
        for x in s:
            reduced = reduce_fn(reduced, x)
        return reduced
```

For example, `reduce` can be used to multiply together all elements of a sequence. Using `mul` as the `reduce_fn` and 1 as the `initial` value, `reduce` can be used to multiply together a sequence of numbers.

例如， `reduce` 可用于将序列的所有元素相乘。使用 `mul` 作为 `reduce_fn` 和1 作为 `initial` 值， `reduce` 可用于将数字序列相乘。

```py
>>> reduce(mul, [2, 4, 8], 1)
64
```

We can find perfect numbers using these higher-order functions as well.

我们也可以使用这些高阶函数找到完美数。

```py
>>> def divisors_of(n):
        divides_n = lambda x: n % x == 0
        return [1] + keep_if(divides_n, range(2, n))
>>> divisors_of(12)
[1, 2, 3, 4, 6]
>>> from operator import add
>>> def sum_of_divisors(n):
        return reduce(add, divisors_of(n), 0)
>>> def perfect(n):
        return sum_of_divisors(n) == n
>>> keep_if(perfect, range(1, 1000))
[1, 6, 28, 496]
```

**Conventional Names.** In the computer science community, the more common name for `apply_to_all` is `map` and the more common name for `keep_if` is `filter`. In Python, the built-in `map` and `filter` are generalizations of these functions that do not return lists. These functions are discussed in Chapter 4. The definitions above are equivalent to applying the `list` constructor to the result of built-in `map` and `filter` calls.

约定俗成的名字。在计算机科学界， `apply_to_all` 更常见的名称是 `map` 而 `keep_if` 更常见的名称是 `filter` 。在 Python 中，内置的 `map` 和 `filter` 是这些不返回列表的函数的泛化。这些函数在第 4 章中讨论。上面的定义等效于将 `list` 构造函数应用于内置 `map` 和 `filter` 调用的结果。

```py
>>> apply_to_all = lambda map_fn, s: list(map(map_fn, s))
>>> keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

The `reduce` function is built into the `functools` module of the Python standard library. In this version, the `initial` argument is optional.

`reduce` 函数内置于 Python 标准库的 `functools` 模块中。在此版本中， `initial` 参数是可选的。

```py
>>> from functools import reduce
>>> from operator import mul
>>> def product(s):
        return reduce(mul, s)
>>> product([1, 2, 3, 4, 5])
120
```

In Python programs, it is more common to use list comprehensions directly rather than higher-order functions, but both approaches to sequence processing are widely used.

在 Python 程序中，更常见的是直接使用列表理解而不是高阶函数，但这两种序列处理方法都被广泛使用。

## 2.3.4  Sequence Abstraction 2.3.4 序列抽象

We have introduced two native data types that satisfy the sequence abstraction: lists and ranges. Both satisfy the conditions with which we began this section: length and element selection. Python includes two more behaviors of sequence types that extend the sequence abstraction.

我们引入了两种满足序列抽象的本机数据类型：列表和范围。两者都满足我们开始本节的条件：长度和元素选择。 Python 包含两个扩展序列抽象的序列类型行为。

**Membership.** A value can be tested for membership in a sequence. Python has two operators `in` and `not in` that evaluate to `True` or `False` depending on whether an element appears in a sequence.

会员资格。可以测试一个值在序列中的成员资格。 Python 有两个运算符 `in` 和 `not in` ，它们的计算结果为 `True` 或 `False` ，具体取决于元素是否出现在序列中。

```py
>>> digits
[1, 8, 2, 8]
>>> 2 in digits
True
>>> 1828 not in digits
True
```

**Slicing.** Sequences contain smaller sequences within them. A *slice* of a sequence is any contiguous span of the original sequence, designated by a pair of integers. As with the `range` constructor, the first integer indicates the starting index of the slice and the second indicates one beyond the ending index.

切片。序列中包含较小的序列。序列的切片是原始序列的任何连续跨度，由一对整数指定。与 `range` 构造函数一样，第一个整数表示切片的起始索引，第二个整数表示结束索引之后的索引。

In Python, sequence slicing is expressed similarly to element selection, using square brackets. A colon separates the starting and ending indices. Any bound that is omitted is assumed to be an extreme value: 0 for the starting index, and the length of the sequence for the ending index.

在 Python 中，序列切片的表达方式类似于元素选择，使用方括号。冒号分隔起始索引和结束索引。任何被省略的界限都被假定为一个极值：0 代表起始索引，序列长度代表结束索引。

```py
>>> digits[0:2]
[1, 8]
>>> digits[1:]
[8, 2, 8]
```

Enumerating these additional behaviors of the Python sequence abstraction gives us an opportunity to reflect upon what constitutes a useful data abstraction in general. The richness of an abstraction (that is, how many behaviors it includes) has consequences. For users of an abstraction, additional behaviors can be helpful. On the other hand, satisfying the requirements of a rich abstraction with a new data type can be challenging. Another negative consequence of rich abstractions is that they take longer for users to learn.

列举 Python 序列抽象的这些额外行为让我们有机会反思什么构成了一般有用的数据抽象。抽象的丰富程度（即它包含多少行为）会产生影响。对于抽象的用户，额外的行为可能会有帮助。另一方面，用新数据类型满足丰富抽象的要求可能具有挑战性。丰富抽象的另一个负面后果是用户需要更长的时间来学习。

Sequences have a rich abstraction because they are so ubiquitous in computing that learning a few complex behaviors is justified. In general, most user-defined abstractions should be kept as simple as possible.

序列具有丰富的抽象，因为它们在计算中无处不在，以至于学习一些复杂的行为是有道理的。通常，大多数用户定义的抽象应该尽可能简单。

**Further reading.** Slice notation admits a variety of special cases, such as negative starting values, ending values, and step sizes. A complete description appears in the subsection called [slicing a list](http://getpython3.com/diveintopython3/native-datatypes.html#slicinglists) in Dive Into Python 3. In this chapter, we will only use the basic features described above.

进一步阅读。切片表示法允许各种特殊情况，例如负起始值、终止值和步长。完整的描述出现在 Dive Into Python 3 中名为切片列表的小节中。在本章中，我们将仅使用上述基本功能。

## 2.3.5  Strings 2.3.5 字符串

Text values are perhaps more fundamental to computer science than even numbers. As a case in point, Python programs are written and stored as text. The native data type for text in Python is called a string, and corresponds to the constructor `str`.

文本值对于计算机科学来说可能比偶数更基础。举个例子，Python 程序是以文本形式编写和存储的。 Python 中文本的本机数据类型称为字符串，对应于构造函数 `str` 。

There are many details of how strings are represented, expressed, and manipulated in Python. Strings are another example of a rich abstraction, one that requires a substantial commitment on the part of the programmer to master. This section serves as a condensed introduction to essential string behaviors.

关于字符串在 Python 中如何表示、表达和操作的细节有很多。字符串是丰富抽象的另一个例子，它需要程序员做出实质性的承诺才能掌握。本节是对基本字符串行为的简要介绍。

String literals can express arbitrary text, surrounded by either single or double quotation marks.

字符串文字可以表示任意文本，用单引号或双引号括起来。

```py
>>> 'I am string!'
'I am string!'
>>> "I've got an apostrophe"
"I've got an apostrophe"
>>> '您好'
'您好'
```

We have seen strings already in our code, as docstrings, in calls to `print`, and as error messages in `assert` statements.

我们已经在我们的代码中看到字符串，如文档字符串，在对 `print` 的调用中，以及在 `assert` 语句中的错误消息。

Strings satisfy the two basic conditions of a sequence that we introduced at the beginning of this section: they have a length and they support element selection.

字符串满足我们在本节开头介绍的序列的两个基本条件：它们具有长度并且支持元素选择。

```py
>>> city = 'Berkeley'
>>> len(city)
8
>>> city[3]
'k'
```

The elements of a string are themselves strings that have only a single character. A character is any single letter of the alphabet, punctuation mark, or other symbol. Unlike many other programming languages, Python does not have a separate character type; any text is a string, and strings that represent single characters have a length of 1.

字符串的元素本身就是只有一个字符的字符串。字符是字母表中的任何单个字母、标点符号或其他符号。与许多其他编程语言不同，Python 没有单独的字符类型；任何文本都是字符串，表示单个字符的字符串的长度为 1。

Like lists, strings can also be combined via addition and multiplication.

与列表一样，字符串也可以通过加法和乘法组合。

```py
>>> 'Berkeley' + ', CA'
'Berkeley, CA'
>>> 'Shabu ' * 2
'Shabu Shabu '
```

**Membership.** The behavior of strings diverges from other sequence types in Python. The string abstraction does not conform to the full sequence abstraction that we described for lists and ranges. In particular, the membership operator `in` applies to strings, but has an entirely different behavior than when it is applied to sequences. It matches substrings rather than elements.

会员资格。字符串的行为不同于 Python 中的其他序列类型。字符串抽象不符合我们为列表和范围描述的完整序列抽象。特别是，成员资格运算符 `in` 适用于字符串，但与应用于序列时具有完全不同的行为。它匹配子字符串而不是元素。

```py
>>> 'here' in "Where's Waldo?"
True
```

**Multiline Literals.** Strings aren't limited to a single line. Triple quotes delimit string literals that span multiple lines. We have used this triple quoting extensively already for docstrings.

多行文字。字符串不限于一行。三重引号分隔跨越多行的字符串文字。我们已经在文档字符串中广泛使用了这种三重引号。

```py
>>> """The Zen of Python
claims, Readability counts.
Read more: import this."""
'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'
```

In the printed result above, the `\n` (pronounced "*backslash en*") is a single element that represents a new line. Although it appears as two characters (backslash and "n"), it is considered a single character for the purposes of length and element selection.

在上面的打印结果中， `\n` （发音为“反斜杠 en”）是一个表示新行的元素。虽然它显示为两个字符（反斜杠和“n”），但出于长度和元素选择的目的，它被视为单个字符。

**String Coercion.** A string can be created from any object in Python by calling the `str` constructor function with an object value as its argument. This feature of strings is useful for constructing descriptive strings from objects of various types.

字符串强制。通过以对象值作为参数调用 `str` 构造函数，可以从 Python 中的任何对象创建字符串。字符串的这一特性对于从各种类型的对象构造描述性字符串很有用。

```py
>>> str(2) + ' is an element of ' + str(digits)
'2 is an element of [1, 8, 2, 8]'
```

**Further reading.** Encoding text in computers is a complex topic. In this chapter, we will abstract away the details of how strings are represented. However, for many applications, the particular details of how strings are encoded by computers is essential knowledge. [The strings chapter of Dive Into Python 3](http://getpython3.com/diveintopython3/strings.html) provides a description of character encodings and Unicode.

进一步阅读。在计算机中编码文本是一个复杂的话题。在本章中，我们将抽象出字符串如何表示的细节。然而，对于许多应用程序而言，计算机如何对字符串进行编码的特定细节是必不可少的知识。 Dive Into Python 3 的字符串章节提供了字符编码和 Unicode 的描述。

## 2.3.6  Trees 2.3.6 树

Our ability to use lists as the elements of other lists provides a new means of combination in our programming language. This ability is called a *closure property* of a data type. In general, a method for combining data values has a closure property if the result of combination can itself be combined using the same method. Closure is the key to power in any means of combination because it permits us to create hierarchical structures — structures made up of parts, which themselves are made up of parts, and so on.

我们使用列表作为其他列表的元素的能力为我们的编程语言提供了一种新的组合方式。这种能力称为数据类型的闭包属性。通常，如果组合结果本身可以使用相同的方法组合，则组合数据值的方法具有闭包属性。闭合是任何组合方式的关键，因为它允许我们创建层次结构——由部分组成的结构，它们本身由部分组成，等等。

We can visualize lists in environment diagrams using *box-and-pointer* notation. A list is depicted as adjacent boxes that contain the elements of the list. Primitive values such as numbers, strings, boolean values, and `None` appear within an element box. Composite values, such as function values and other lists, are indicated by an arrow.

我们可以使用方框指针表示法在环境图中可视化列表。列表被描述为包含列表元素的相邻框。数字、字符串、布尔值和 `None` 等原始值出现在元素框内。复合值（例如函数值和其他列表）由箭头指示。

Nesting lists within lists can introduce complexity. The *tree* is a fundamental data abstraction that imposes regularity on how hierarchical values are structured and manipulated.

在列表中嵌套列表会带来复杂性。树是一种基本的数据抽象，它对分层值的结构和操作方式施加了规律性。

A tree has a root label and a sequence of branches. Each branch of a tree is a tree. A tree with no branches is called a leaf. Any tree contained within a tree is called a sub-tree of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.

一棵树有一个根标签和一系列分支。树的每个分支都是一棵树。没有树枝的树称为叶。树中包含的任何树都称为该树的子树（例如分支的分支）。树的每个子树的根称为该树中的一个节点。

The data abstraction for a tree consists of the constructor `tree` and the selectors `label` and `branches`. We begin with a simplified version.

树的数据抽象由构造函数 `tree` 和选择器 `label` 和 `branches` 组成。我们从一个简化版本开始。

```py
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
```

A tree is well-formed only if it has a root label and all branches are also trees. The `is_tree` function is applied in the `tree` constructor to verify that all branches are well-formed.

只有当树有根标签并且所有分支也是树时，树才是良构的。 `is_tree` 函数应用于 `tree` 构造函数以验证所有分支是否格式正确。

```py
>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True
```

The `is_leaf` function checks whether or not a tree has branches.

`is_leaf` 函数检查树是否有分支。

```py
>>> def is_leaf(tree):
        return not branches(tree)
```

Trees can be constructed by nested expressions. The following tree `t` has root label 3 and two branches.

可以通过嵌套表达式构造树。以下树 `t` 具有根标签 3 和两个分支。

```py
>>> t = tree(3, [tree(1), tree(2, [tree(1), tree(1)])])
>>> t
[3, [1], [2, [1], [1]]]
>>> label(t)
3
>>> branches(t)
[[1], [2, [1], [1]]]
>>> label(branches(t)[1])
2
>>> is_leaf(t)
False
>>> is_leaf(branches(t)[0])
True
```

Tree-recursive functions can be used to construct trees. For example, the nth Fibonacci tree has a root label of the nth Fibonacci number and, for `n > 1`, two branches that are also Fibonacci trees. A Fibonacci tree illustrates the tree-recursive computation of a Fibonacci number.

树递归函数可用于构造树。例如，第 n 个 Fibonacci 树的根标签是第 n 个 Fibonacci 数，对于 `n > 1` ，两个分支也是 Fibonacci 树。斐波那契树说明了斐波那契数的树递归计算。

```py
>>> def fib_tree(n):
        if n == 0 or n == 1:
            return tree(n)
        else:
            left, right = fib_tree(n-2), fib_tree(n-1)
            fib_n = label(left) + label(right)
            return tree(fib_n, [left, right])
>>> fib_tree(5)
[5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]
```

Tree-recursive functions are also used to process trees. For example, the `count_leaves` function counts the leaves of a tree.

树递归函数也用于处理树。例如， `count_leaves` 函数计算树的叶子数。

```py
>>> def count_leaves(tree):
      if is_leaf(tree):
          return 1
      else:
          branch_counts = [count_leaves(b) for b in branches(tree)]
          return sum(branch_counts)
        
>>> count_leaves(fib_tree(5))
8
```

**Partition trees.** Trees can also be used to represent the partitions of an integer. A partition tree for `n` using parts up to size `m` is a binary (two branch) tree that represents the choices taken during computation. In a non-leaf partition tree:

分区树。树也可以用来表示整数的划分。 `n` 的分区树使用最大大小为 `m` 的部分是二叉（双分支）树，表示在计算期间做出的选择。在非叶子分区树中：

- the left (index 0) branch contains all ways of partitioning `n` using at least one `m`,
- 左侧（索引 0）分支包含使用至少一个 `m` 划分 `n` 的所有方式，
- the right (index 1) branch contains partitions using parts up to `m-1`, and
- 右侧（索引 1）分支包含使用最多 `m-1` 的部分的分区，并且
- the root label is `m`.
- 根标签是 `m` 。

The labels at the leaves of a partition tree express whether the path from the root of the tree to the leaf represents a successful partition of `n`.

分区树叶子上的标签表示从树根到叶子的路径是否代表 `n` 分区成功。

```py
>>> def partition_tree(n, m):
        """Return a partition tree of n using parts of up to m."""
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left = partition_tree(n-m, m)
            right = partition_tree(n, m-1)
            return tree(m, [left, right])
            
>>> partition_tree(2, 2)
[2, [True], [1, [1, [True], [False]], [False]]]
```

Printing the partitions from a partition tree is another tree-recursive process that traverses the tree, constructing each partition as a list. Whenever a `True` leaf is reached, the partition is printed.

从分区树打印分区是另一个遍历树的树递归过程，将每个分区构造为一个列表。每当到达 `True` 叶子时，就会打印分区。

```py
>>> def print_parts(tree, partition=[]):
        if is_leaf(tree):
            if label(tree):
                print(' + '.join(partition))
        else:
            left, right = branches(tree)
            m = str(label(tree))
            print_parts(left, partition + [m])
            print_parts(right, partition)
            
>>> print_parts(partition_tree(6, 4))
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```

Slicing can be used on the branches of a tree as well. For example, we may want to place a restriction on the number of branches in a tree. A binary tree is either a leaf or a sequence of at most two binary trees. A common tree transformation called *binarization* computes a binary tree from an original tree by grouping together adjacent branches.

切片也可以用在树的树枝上。例如，我们可能想限制一棵树的分支数量。二叉树是一个叶子或最多两个二叉树的序列。一种称为二值化的常见树转换通过将相邻分支组合在一起，从原始树计算二叉树。

```py
>>> def right_binarize(tree):
        """Construct a right-branching binary tree."""
        if is_leaf(tree):
            return tree
        if len(tree) > 2:
            tree = [tree[0], tree[1:]]
        return [right_binarize(b) for b in tree]

>>> right_binarize([1, 2, 3, 4, 5, 6, 7])
[1, [2, [3, [4, [5, [6, 7]]]]]]
```

## 2.3.7  Linked Lists 2.3.7 链表

So far, we have used only native types to represent sequences. However, we can also develop sequence representations that are not built into Python. A common representation of a sequence constructed from nested pairs is called a *linked list*. The environment diagram below illustrates the linked list representation of a four-element sequence containing 1, 2, 3, and 4.

到目前为止，我们只使用原生类型来表示序列。但是，我们也可以开发未内置于 Python 中的序列表示。由嵌套对构造的序列的常见表示称为链表。下面的环境图说明了包含 1、2、3 和 4 的四元素序列的链表表示。

A linked list is a pair containing the first element of the sequence (in this case 1) and the rest of the sequence (in this case a representation of 2, 3, 4). The second element is also a linked list. The rest of the inner-most linked list containing only 4 is `'empty'`, a value that represents an empty linked list.

链表是一对包含序列的第一个元素（在本例中为 1）和序列的其余部分（在本例中为 2、3、4 的表示）。第二个元素也是一个链表。仅包含 4 的最内部链表的其余部分是 `'empty'` ，一个表示空链表的值。

Linked lists have recursive structure: the rest of a linked list is a linked list or `'empty'`. We can define an abstract data representation to validate, construct, and select the components of linked lists.

链表具有递归结构：链表的其余部分是链表或 `'empty'` 。我们可以定义一个抽象数据表示来验证、构造和选择链表的组件。

```py
>>> empty = 'empty'
>>> def is_link(s):
        """s is a linked list if it is empty or a (first, rest) pair."""
        return s == empty or (len(s) == 2 and is_link(s[1]))
>>> def link(first, rest):
        """Construct a linked list from its first element and the rest."""
        assert is_link(rest), "rest must be a linked list."
        return [first, rest]
>>> def first(s):
        """Return the first element of a linked list s."""
        assert is_link(s), "first only applies to linked lists."
        assert s != empty, "empty linked list has no first element."
        return s[0]
>>> def rest(s):
        """Return the rest of the elements of a linked list s."""
        assert is_link(s), "rest only applies to linked lists."
        assert s != empty, "empty linked list has no rest."
        return s[1]
```

Above, `link` is a constructor and `first` and `rest` are selectors for an abstract data representation of linked lists. The behavior condition for a linked list is that, like a pair, its constructor and selectors are inverse functions.

上面， `link` 是一个构造函数， `first` 和 `rest` 是链表的抽象数据表示的选择器。链表的行为条件是，就像一对一样，它的构造函数和选择器是反函数。

- If a linked list `s` was constructed from first element `f` and linked list `r`, then `first(s)` returns `f`, and `rest(s)` returns `r`.
- 如果链表 `s` 由第一个元素 `f` 和链表 `r` 构成，则 `first(s)` 返回 `f` ， `rest(s)` 返回 `r` 。

We can use the constructor and selectors to manipulate linked lists.

我们可以使用构造函数和选择器来操作链表。

```py
>>> four = link(1, link(2, link(3, link(4, empty))))
>>> first(four)
1
>>> rest(four)
[2, [3, [4, 'empty']]]
```

Our implementation of this kind of abstract data uses pairs that are two-element `list` values. It is worth noting that we were also able to implement pairs using functions, and we can implement linked lists using any pairs, therefore we could implement linked lists using functions alone.

我们对这种抽象数据的实现使用双元素 `list` 值对。值得注意的是，我们还可以使用函数来实现对，我们可以使用任何对来实现链表，因此我们可以单独使用函数来实现链表。

The linked list can store a sequence of values in order, but we have not yet shown that it satisfies the sequence abstraction. Using the abstract data representation we have defined, we can implement the two behaviors that characterize a sequence: length and element selection.

链表可以按顺序存储一系列值，但我们还没有证明它满足序列抽象。使用我们定义的抽象数据表示，我们可以实现表征序列的两种行为：长度和元素选择。

```py
>>> def len_link(s):
        """Return the length of linked list s."""
        length = 0
        while s != empty:
            s, length = rest(s), length + 1
        return length

>>> def getitem_link(s, i):
        """Return the element at index i of linked list s."""
        while i > 0:
            s, i = rest(s), i - 1
        return first(s)
```

Now, we can manipulate a linked list as a sequence using these functions. (We cannot yet use the built-in `len` function, element selection syntax, or `for` statement, but we will soon.)
现在，我们可以使用这些函数将链表作为序列来操作。 （我们还不能使用内置的 `len` 函数、元素选择语法或 `for` 语句，但我们很快就会使用。）

```py
>>> len_link(four)
4
>>> getitem_link(four, 1)
2
```

The series of environment diagrams below illustrate the iterative process by which `getitem_link` finds the element 2 at index 1 in a linked list. Below, we have defined the linked list `four` using Python primitives to simplify the diagrams. This implementation choice violates an abstraction barrier, but allows us to inspect the computational process more easily for this example.

下面的一系列环境图说明了 `getitem_link` 在链表中找到索引为 1 的元素 2 的迭代过程。下面，我们使用 Python 原语定义了链表 `four` 以简化图表。这种实现选择违反了抽象障碍，但允许我们更轻松地检查此示例的计算过程。

First, the function `getitem_link` is called, creating a local frame.

首先，调用函数 `getitem_link` ，创建一个本地框架。

The expression in the `while` header evaluates to true, which causes the assignment statement in the `while` suite to be executed. The function `rest` returns the sublist starting with 2.

`while` 标头中的表达式计算结果为真，这导致执行 `while` 套件中的赋值语句。 `rest` 函数返回以 2 开头的子列表。

Next, the local name `s` will be updated to refer to the sub-list that begins with the second element of the original list. Evaluating the `while` header expression now yields a false value, and so Python evaluates the expression in the return statement on the final line of `getitem_link`.

接下来，本地名称 `s` 将更新为引用以原始列表的第二个元素开头的子列表。现在评估 `while` 标头表达式会产生一个假值，因此 Python 会评估 `getitem_link` 最后一行的 return 语句中的表达式。

This final environment diagram shows the local frame for the call to `first`, which contains the name `s` bound to that same sub-list. The `first` function selects the value 2 and returns it, which will also be returned from `getitem_link`.

这个最终的环境图显示了调用 `first` 的本地框架，其中包含绑定到同一子列表的名称 `s` 。 `first` 函数选择值 2 并返回它，它也将从 `getitem_link` 返回。

This example demonstrates a common pattern of computation with linked lists, where each step in an iteration operates on an increasingly shorter suffix of the original list. This incremental processing to find the length and elements of a linked list does take some time to compute. Python's built-in sequence types are implemented in a different way that does not have a large cost for computing the length of a sequence or retrieving its elements. The details of that representation are beyond the scope of this text.

此示例演示了链表的常见计算模式，其中迭代中的每个步骤都对原始列表的越来越短的后缀进行操作。这种查找链表长度和元素的增量处理确实需要一些时间来计算。 Python 的内置序列类型以不同的方式实现，计算序列长度或检索其元素的成本并不高。该表示的详细信息超出了本文的范围。

**Recursive manipulation.** Both `len_link` and `getitem_link` are iterative. They peel away each layer of nested pair until the end of the list (in `len_link`) or the desired element (in `getitem_link`) is reached. We can also implement length and element selection using recursion.

递归操作。 `len_link` 和 `getitem_link` 都是迭代的。它们剥离嵌套对的每一层，直到到达列表的末尾（在 `len_link` 中）或所需的元素（在 `getitem_link` 中）。我们还可以使用递归实现长度和元素选择。

```py
>>> def len_link_recursive(s):
        """Return the length of a linked list s."""
        if s == empty:
            return 0
        return 1 + len_link_recursive(rest(s))
>>> def getitem_link_recursive(s, i):
        """Return the element at index i of linked list s."""
        if i == 0:
            return first(s)
        return getitem_link_recursive(rest(s), i - 1)
>>> len_link_recursive(four)
4
>>> getitem_link_recursive(four, 1)
2
```

These recursive implementations follow the chain of pairs until the end of the list (in `len_link_recursive`) or the desired element (in `getitem_link_recursive`) is reached.

这些递归实现遵循成对链，直到到达列表末尾（在 `len_link_recursive` 中）或到达所需元素（在 `getitem_link_recursive` 中）。

Recursion is also useful for transforming and combining linked lists.

递归对于转换和组合链表也很有用。

```py
>>> def extend_link(s, t):
        """Return a list with the elements of s followed by those of t."""
        assert is_link(s) and is_link(t)
        if s == empty:
            return t
        else:
            return link(first(s), extend_link(rest(s), t))

>>> extend_link(four, four)
[1, [2, [3, [4, [1, [2, [3, [4, 'empty']]]]]]]]

>>> def apply_to_all_link(f, s):
        """Apply f to each element of s."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            return link(f(first(s)), apply_to_all_link(f, rest(s)))

>>> apply_to_all_link(lambda x: x*x, four)
[1, [4, [9, [16, 'empty']]]]

>>> def keep_if_link(f, s):
        """Return a list with elements of s for which f(e) is true."""
        assert is_link(s)
        if s == empty:
            return s
        else:
            kept = keep_if_link(f, rest(s))
            if f(first(s)):
                return link(first(s), kept)
            else:
                return kept
>>> keep_if_link(lambda x: x%2 == 0, four)
[2, [4, 'empty']]

>>> def join_link(s, separator):
        """Return a string of all elements in s separated by separator."""
        if s == empty:
            return ""
        elif rest(s) == empty:
            return str(first(s))
        else:
            return str(first(s)) + separator + join_link(rest(s), separator)
        
>>> join_link(four, ", ")
'1, 2, 3, 4'
```

**Recursive Construction.** Linked lists are particularly useful when constructing sequences incrementally, a situation that arises often in recursive computations.

递归构造。链表在递增构造序列时特别有用，递归计算中经常出现这种情况。

The `count_partitions` function from Chapter 1 counted the number of ways to partition an integer `n` using parts up to size `m` via a tree-recursive process. With sequences, we can also enumerate these partitions explicitly using a similar process.

第 1 章中的 `count_partitions` 函数计算了通过树递归过程使用最大大小为 `m` 的部分对整数 `n` 进行分区的方法数。使用序列，我们还可以使用类似的过程显式枚举这些分区。

We follow the same recursive analysis of the problem as we did while counting: partitioning `n` using integers up to `m` involves either

我们遵循与计数时相同的问题递归分析：使用高达 `m` 的整数划分 `n` 涉及

1. partitioning `n-m` using integers up to `m`, or
2. 使用不超过 `m` 的整数对 `n-m` 进行分区，或者
3. partitioning `n` using integers up to `m-1`.
4. 使用不超过 `m-1` 的整数对 `n` 进行分区。

For base cases, we find that 0 has an empty partition, while partitioning a negative integer or using parts smaller than 1 is impossible.

对于基本情况，我们发现 0 有一个空分区，而分区负整数或使用小于 1 的部分是不可能的。

```py
>>> def partitions(n, m):
        """Return a linked list of partitions of n using parts of up to m.
        Each partition is represented as a linked list.
        """
        if n == 0:
            return link(empty, empty) # A list containing the empty partition
        elif n < 0 or m == 0:
            return empty
        else:
            using_m = partitions(n-m, m)
            with_m = apply_to_all_link(lambda s: link(m, s), using_m)
            without_m = partitions(n, m-1)
            return extend_link(with_m, without_m)
```

In the recursive case, we construct two sublists of partitions. The first uses `m`, and so we prepend `m` to each element of the result `using_m` to form `with_m`.

在递归的情况下，我们构造两个分区子列表。第一个使用 `m` ，因此我们将 `m` 添加到结果 `using_m` 的每个元素之前以形成 `with_m` 。

The result of `partitions` is highly nested: a linked list of linked lists, and each linked list is represented as nested pairs that are `list` values. Using `join_link` with appropriate separators, we can display the partitions in a human-readable manner.

`partitions` 的结果是高度嵌套的：一个链表的链表，每个链表表示为嵌套对，都是 `list` 的值。使用带有适当分隔符的 `join_link` ，我们可以以人类可读的方式显示分区。

```py
>>> def print_partitions(n, m):
        lists = partitions(n, m)
        strings = apply_to_all_link(lambda s: join_link(s, " + "), lists)
        print(join_link(strings, "\n"))

>>> print_partitions(6, 4)
4 + 2
4 + 1 + 1
3 + 3
3 + 2 + 1
3 + 1 + 1 + 1
2 + 2 + 2
2 + 2 + 1 + 1
2 + 1 + 1 + 1 + 1
1 + 1 + 1 + 1 + 1 + 1
```